
# Практическое задание

## UML

### Процесс

1. Определить главную функциональность системы (реального объекта в окружающем мире) 
2. Исходя из п. 1 выделить юз кейсы, они будут является функциональными требованиями
3. Определить не функциональные требования
4. Определить ограничения 
5. Определить кто будет пользоваться системой (акторы)
6. Определить как акторы будут пользоваться системой ([[#0. Диаграмма вариантов использования]])
7. Описать юзкейсы и стандартные сценарии их использования (лимитации, кто выполняет, результат, предпосылки, альтернативные сценарии)
8. Описать главные сценарии юзкейсов ([[#7. Диаграммы деятельности]])
9. Выявить главные элементы системы (Возможно блок-схема)
10. Описать главный/стандартный сценарий работы системы ([[#3. Диаграмма последовательности]])
11. Описать аппаратное обеспечение системы ([[#4. Диаграммы развёртывания]])
12. Выявить подпроблемы которые необходимо решить/подсистемы (БД, передача сообщений, real-time device control и т.п.)
13. Описать сущности подсистемы ([[#2. Диаграммы классов]])
14. Описать механизм работы подсистемы 
15. Описать архитектуру системы ([[#8. Диаграммы компонентов]])
### 0. Диаграммы вариантов использования

Прецеденты – это технология определения функциональных требова ний к системе. Работа прецедентов заключается в описании типичных взаимодействий между пользователями системы и самой системой и предоставлении описания процесса ее функционирования.

Прецеденты (Use Cases), или варианты использования, – замечательная идея, которую зачем-то чрезмерно усложнили. Главная задача при работе с прецедентами в том, чтобы сделать их простыми.

 Вместо того чтобы описывать прецеденты в лоб, я предпочитаю подкрасться к ним сзади и начать с описания сценариев. **Сценарий** (scenario) – это последовательность шагов, описывающих взаимодействие пользовате ля и системы.
 
В терминах прецедента пользователи называются **актерами**. **Актер** (actor) представляет собой некую роль, которую пользователь играет по отношению к системе. Актерами могут быть пользователь, торго вый представитель пользователя, менеджер по продажам и товаровед

Вы начинаете с выбора одного из сценариев в качестве главного успешного сценария (main success sce nario). Каждый шаг в прецеденте – это элемент взаимодействия актера с систе мой. Каждый шаг должен быть простым утверждением и должен четко указывать, кто выполняет этот шаг.

![[Pasted image 20240602183337.png]]

Структура прецедента – это отличный инструмент для поиска альтер натив главного успешного сценария. На каждом шаге спрашивайте: «Что может еще произойти?» и в частности «Что может пойти не так?» Обычно лучше сначала изучить все возможные условия расширения, чтобы потом не увязнуть в трясине работы над последствиями. Таким образом, вы, возможно, обдумаете больше условий, что приведет к мень шему количеству ошибок, которые потом пришлось бы отлавливать.

Наряду с шагами сценария можно вставить в прецедент дополнитель ную общую информацию. 
- Предусловие (precondition) описывает действия, обязательно вы полняемые системой перед тем, как она разрешит начать работу прецедента. Это полезная информация, позволяющая разработчи кам не проверять некоторые условия в их программе. 
- Гарантия (guarantee) описывает обязательные действия системы по окончании работы шаблона ответа. Успешные гарантии выполня ются после успешного сценария; минимальные гарантии выполня ются после любого сценария. 
- Триггер (trigger) определяет событие, инициирующее выполнение прецедента.

![[Pasted image 20240602183508.png]]

В языке UML помимо отношения **«include» (включает)** есть и другие типы отношений между прецедентами, например отношение **«extend» (расширяет)**.
#### ПРИМЕРЫ

![[Pasted image 20240602170037.png]]

![[Pasted image 20240602181953.png]]
### 2. Диаграммы классов

#### Общее

**Диаграмма классов** описывает типы объектов системы и различного рода статические отношения, которые существуют между ними. На диаграммах классов отображаются также свойства классов, операции классов и ограничения, которые накладываются на связи между объек тами. В UML термин **функциональность** (feature) применяется в каче стве основного термина, описывающего и свойства, и операции класса.

![[Pasted image 20240602154210.png]]

Типы стрелок:

![[Pasted image 20240602160647.png]]


#### Классы

В прямоугольнике класса может быть несколько отделений. В верхнем записывается имя класса, в среднем – переменные-члены, в нижнем – методы.

![[Pasted image 20240602161902.png]]
#### Ассоциация

Ассоциации между классами чаще всего представляют переменные экземпляра, в которых хранятся ссылки на другие объекты. Например, на рис. 19.3 показана ассоциация между классами Phone и Button. Направление стрелки говорит о том, что в Phone хранится ссылка на Button. Рядом со стрелкой указывается имя переменной экземпляра, а число говорит о том, сколько в этой переменной может храниться ссылок.

![[Pasted image 20240602162009.png]]

Значительная часть информации, которую можно указать в атрибуте, появляется в ассоциации.

![[Pasted image 20240602161150.png]]

#### Наследование

Если небрежно отнестись к рисованию стрелок, то будет непонятно, имеется ли в виду наследование или ассоциация. Чтобы не возникало путаницы, я часто располагаю классы, связанные отношением наследования, по вертикали, а связанные отношением ассоциации – по горизонтали.

В UML направления всех стрелок определяются зависимостью в исходном коде. Так как имя Employee упомянуто в классе SalariedEmployee, а не наоборот, то стрелка указывает на Employee. Таким образом, в UML стрелка наследования всегда направлена в сторону базового класса.

![[Pasted image 20240602162145.png]]

#### Реализация

![[Pasted image 20240602162256.png]]

![[Pasted image 20240602160545.png]]
#### Зависимость

Считается, что между двумя элементами существует зависимость (de pendency), если изменения в определении одного элемента (сервера) могут вызвать изменения в другом элементе (клиенте).

![[Pasted image 20240602161355.png]]
#### Агрегация и композиция

К одним из наиболее частых источников недоразумений в UML –мож но отнести **агрегацию и композицию**. В нескольких словах это можно объяснить так: **Агрегация** (aggregation) – это отношение типа «часть целого». Точно так же можно сказать, что двигатель и колеса пред ставляют собой части автомобиля.

![[Pasted image 20240602155625.png]]

Разница:

| **Агрегация**                                                                                                        | **Композиция**                                                                                                           |
| -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| В отношениях **агрегации** объекты, связанные друг с другом, **могут оставаться в пределах системы друг без друга**. | В отношениях **композиции** объекты, связанные друг с другом, **не могут оставаться в области действия друг без друга**. |
| При агрегировании связанные объекты не зависят от другого объекта.                                                   | По составу объекты сильно зависят друг от друга.                                                                         |


#### ПРИМЕРЫ

![[Pasted image 20240602173738.png]]

![[Pasted image 20240602174303.png]]


### 3. Диаграмма последовательности

#### Общее

Диаграммы взаимодействия (interaction diagrams) описывают взаимодействие групп объектов в различных условиях их поведения. Обычно **диаграмма последовательности** описывает один сценарий. На диаграмме показаны экземпляры объектов и сообщения, которыми обмениваются объекты в рамках одного прецедента (use case).

Диаграммы последовательности показывают взаимодействие, представляя каждого участника вместе с его линией жизни (lifeline), которая идет вертикально вниз и упорядочивает сообщения на странице; сообщения также следует читать сверху вниз.

Пунктирные линии, идущие вниз от объектов и действующего лица, называются линиями жизни. Сообщения, которые один объект посылает другому, показаны стрелками, соединяющими две линии жизни. Аргументы указываются либо в скобках после имени, либо рядом с маркерами данных (небольшие стрелки с кружком на конце). Временная ось направлена сверху вниз, то есть чем ниже расположено сообщение, тем позже оно послано.

Узкий вытянутый прямоугольник на линии жизни объекта Page называется активацией1 . Активации необязательны, большинство диаграмм обходится без них. Активация обозначает время, в течение которого выполняется функция. 

На диаграмме последовательности можно показать создание объекта. Для этого применяется соглашение, представленное на рис. 18.2. Непомеченная стрелка сообщения оканчивается на самом создаваемом объекте, а не на его линии жизни. Таким образом, можно предположить, что класс ShapeFactory реализован примерно так, как показано в листинге 18.2:

![[Pasted image 20240602175148.png]]

На UML-диаграмме можно изобразить простой цикл, заключив повторяющиеся сообщения в прямоугольник. Условие цикла записывается в квадратных скобках и помещается где-то внутри прямоугольника, обычно в правом нижнем углу. См. рис. 18.4.

![[Pasted image 20240602175239.png]]

**Не рисуйте диаграммы последовательности, содержащие слишком много объектов и сообщений**. Их никто не сможет прочитать. И не будет читать. Это только пустая трата времени. Лучше научитесь рисовать несколько небольших диаграмм, передающих суть того, что вы пытаетесь сделать.

Сообщению payEmployee предшествует выражение повтора: `*[foreach id in idList]` Звездочка информирует о том, что это итерация, то есть сообщение должно повторно посылаться до тех пор, пока не станет ложным сторожевое условие в квадратных скобках.

![[Pasted image 20240602175424.png]]

Обратите внимание на активацию рядом со сторожевым условием `[payday]`. Так обозначается предложение if. Вторая активация получает управление, только если сторожевое условие истинно. Иными словами, если isPayDay возвращает true, то методы calculatePay, calculateDeductions и sendPayment будут выполняться, иначе нет.
#### ПРИМЕРЫ

![[Pasted image 20240602171823.png]]

![[Pasted image 20240602174702.png]]

![[Pasted image 20240602174757.png]]
### 4. Диаграммы развёртывания

#### Общее

**Диаграммы развертывания** представляют физическое расположение системы, показывая, на каком физическом оборудовании запускается та или иная составляющая программного обеспечения.

На рис. 8.1 показан пример простой диаграммы развертывания. Глав ными элементами диаграммы являются узлы, связанные информаци онными путями. **Узел** (node) – это то, что может содержать программ ное обеспечение. Узлы бывают двух типов. **Устройство** (device) – это физическое оборудование: компьютер или устройство, связанное с сис темой. **Среда выполнения** (execution environment) – это программное обеспечение, которое само может включать другое программное обес печение, например операционную систему или процессконтейнер.

![[Pasted image 20240602182813.png]]

Узлы могут содержать **артефакты** (artifacts), которые являются физи ческим олицетворением программного обеспечения; обычно это файлы. Такими файлами могут быть исполняемые файлы

Артефакты часто являются реализацией компонентов. Это можно по казать, задав значенияметки внутри прямоугольников артефактов. Информационные пути между узлами представляют обмен информа цией в системе. Можно сопровождать эти пути информацией об ис пользуемых информационных протоколах.
#### ПРИМЕРЫ

![[Pasted image 20240602171746.png]]

![[Pasted image 20240602181805.png]]
### 5. Диаграммы состояний

#### Общее

**Диаграммы состояний** (state machine diagrams) – это известная техно логия описания поведения системы.

Черный кружок в левом верхнем углу диаграммы называется начальным псевдосостоянием. Диаграмма со стояния начинается с состояния создаваемого объекта контроллера: состояния Wait (Ожидание). На диаграмме это обозначено с помощью начального псевдосостояния (initial pseudostate), которое не является состоянием, но имеет стрелку, указывающую на начальное состояние.

![[Pasted image 20240602175807.png]]

Переход (transition) означает перемещение из одного состояния в дру гое. Каждый переход имеет свою метку, которая состоит из трех частей: `триггеридентификатор [защита]/активность (triggersignature [guard]/acti vity)`. Все они не обязательны. Как правило, триггеридентификатор – это единственное событие, которое может вызвать изменение состояния.

Состояния могут реагировать на события без совершения перехода, ис пользуя внутренние активности (internal activities), и в этом случае событие, защита и активность размещаются внутри прямоугольника состояния.

![[Pasted image 20240602180145.png]]

Часто бывает, что несколько состояний имеют общие переходы и внут ренние активности. В таких случаях можно их превратить в подсо стояния (substates), а общее поведение перенести в суперсостояние (su perstate), как показано на рис. 10.4.

![[Pasted image 20240602180240.png]]

Взгляните на ДПС турникета в метро, изображенную на рис. 15.8. Ее можно без труда представить в виде ТПС, как показано в табл. 15.1.

![[Pasted image 20240602180610.png]]
#### ПРИМЕРЫ

![[Pasted image 20240602180324.png]]

![[Pasted image 20240602174426.png]]
### 7. Диаграммы деятельности

#### Общее

**Диаграммы деятельности** – это технология, позволяющая описывать логику процедур, бизнеспроцессы и потоки работ. Во многих случаях они напоминают блоксхемы, но принципиальная разница между диа граммами деятельности и нотацией блоксхем заключается в том, что первые поддерживают параллельное процессы.

Мы стартуем с начального узла (initial node), а затем выполняем опера цию Receive Order (Принять заказ). Затем идет ветвление (fork), кото рое имеет один входной поток и несколько выходных параллельных потоков. Из рис. 11.1 видно, что операции Fill Order (Заполнить заявку), Send Invoice (Послать счет) и следующие за ними выполняются параллель но. По существу, в данном случае это означает, что последователь ность операций не имеет значения. Я могу заполнить заявку, послать счет, доставить товар (Delivery), а затем получить оплату (Receive Pay ment); или я могу послать счет, получить оплату, заполнить заявку, а затем доставить товар. Посмотрите на рисунок.

![[Pasted image 20240602180727.png]]

Диаграмма только устанавливает правила обязательной последовательности действий, которым я должен следовать. Это важно для моделирования бизнеспроцессов, поскольку эти процессы часто выполняются параллельно. 

Диаграммы деятельности рассказывают о том, что происходит, но ни чего не говорят о том, кто какие действия выполняет. В программиро вании это означает, что диаграмма не отражает, какой класс является ответственным за ту или иную операцию.

Можно разбить диаграмму деятельности на разделы (partitions), что бы показать, кто что делает, то есть какие операции выполняет тот или иной класс или подразделение предприятия.

![[Pasted image 20240602181527.png]]
#### ПРИМЕРЫ

![[Pasted image 20240602170928.png]]

![[Pasted image 20240602181619.png]]
### 8. Диаграммы компонентов

#### Общее

*Компоненты – это не технология. Технические специалисты считают их трудными для понимания. Компоненты – это скорее стиль отношения клиентов к программному обеспечению. Они хотят иметь возможность покупать необходимое им программное обеспечение частями, а также иметь возможность обновлять его, как они обновляют свою стереосис тему. Они хотят, чтобы новые компоненты работали так же, как и прежние, и обновлять их согласно своим планам, а не по указанию произво дителей. Они хотят, чтобы системы различных производителей могли работать вместе и были взаимозаменяемыми. Это очень разумные требо вания. Одна загвоздка: их трудно выполнить. (Ральф Джонсон)*

Важно то, что компоненты представляют элементы, которые можно независимо друг от друга купить и обновить. В результате разделение системы на компоненты является в большей мере маркетинговым ре шением, чем техническим.

На рис. 14.2 показан пример простой диаграммы компонентов. В этом примере компонент Till (Касса) может взаимодействовать с компонен том Sales Server (Сервер продаж) с помощью интерфейса sales message (Сообщение о продажах). Поскольку сеть ненадежна, то компонент Message Queue (Очередь сообщений) установлен так, чтобы касса могла общаться с сервером, когда сеть работает, и разговаривать с очередью сообщений, когда сеть отключена. Тогда очередь сообщений сможет поговорить с сервером, когда сеть снова станет доступной.
#### ПРИМЕРЫ

![[Pasted image 20240602182444.png]]
### Библиография

1. [Robert Cecil Martin, The Principles, Patterns, and Practices of Agile Software Development, PrenticeHall, 2003.](https://vk.com/doc10903696_271681953?hash=jQim2SvPkIsc64jlh2VZBOueSi3nZE3jYLnqOZWx6X0&dl=5XOqLZPuKIBMAASPLh1vMZOjGxqhIdP9ZJZxEbrKj2c)
2. [Grady Booch «Object-Oriented Analysis and Design with Applications», 2-d ed. Addison-Wesley, 1994.1](https://zjnu2017.github.io/OOAD/reading/Object.Oriented.Analysis.and.Design.with.Applications.3rd.Edition.by.Booch.pdf)
3. [Мартин Фаулер UML Основы](https://old-vt.chuvsu.ru/RmtLrn/%D0%9A%D0%B0%D1%84%D0%B5%D0%B4%D1%80%D0%B0%20%D0%9A%D0%A2%20(%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D1%8B%20%D1%81%20%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%BE%D0%B9%20%D0%9A%D0%A2)/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%98%D0%A1_%D0%90%D0%BB%D0%B5%D0%BA%D1%81%D0%B0%D0%BD%D0%B4%D1%80%D0%BE%D0%B2%20%D0%90%D0%A5/UML_%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B.pdf)

### Тестовое задание

#### Задание

Процесс автоматизированной проверки лабораторных работ по предмету «Языки высокого уровня». Студент загружает в автоматизированную систему исходный код программы-решения, указывает проверяемое задание и язык программирования на котором написан исходный код.

На первом этапе производится автоматическая проверка решения на наборе эталонных тестов для выбранного задания (количество тестов для одного задания >= 10). Решение компилируется соответствующим компилятором и запускается на различных входных данных. Для ускорения проверки используется пул из трех потоков (т.е. могут одновременно проверяться до трех тестов). Тесты считаются пройденными если:

1.   Время исполнения не превысило установленного для теста лимита
2.   Выделенная память не превысила установленного для теста лимита
3.   Процедура верификации установила, что ответ выданный программой-решением студента правильный

В случае если хотя бы один тест не пройден, формируется специальный отчет о причинах ошибки и отдается студенту.

Если автоматические тесты пройдены, то производится дополнительный лексический и синтаксический разбор программы-решения, а затем проверяется истинность определенного набора правил-продукций для полученного дерева синтаксического разбора. Если результат проверки хотя бы одно правила будет ложным, формируется специальный отчет о причинах ошибки и отдается студенту.

Если все проверки были успешны, исходник для ревизии отправляется преподавателю, который принимает окончательное решение о правильности выполнения лабораторной работы. В случае отрицательного решения преподаватель описывает недочеты решения, и они пересылаются студенту. В случае положительного решения студент уведомляется о нем.

- Построить диаграмму состояний
- Построить диаграмму взаимодействия,
- Построить диаграмму развертывания,
- Построить прецедентов (вариантов использования)
- Построить диаграмму активности,
- Построить диаграмму классов

#### Решение

##### Общее

**Функциональные требования:**
- загрузка кода
- комплияция загруженного кода 
- параллельный запуск программы на различных тестах
- проверка соответствия результата кода - ответу
- лексический разбор программы-решения
- синтаксический разбор программы-решения
- выставление статуса решения

**Ограничения:**
- лимит времени на исполнение кода
- лимит памяти на исполнение кода

Система расчитана на 2 актора: **студент** и **преподаватель**

Что должен уметь **студент**:
- посмотреть список назначеных ЛР
- посмотреть список ЯП
- загрузить код-решение
- посмотреть отчёт об ошибках компиляции
- посмотреть отчёт об ошибках дополнительного разбора
- посмотреть комментарий преподавателя
- посмотреть статус решения

Что должен уметь **преподаватель:**
- посмотреть полученное решение 
- посмотреть ЛР 
- поставить статус ЛР
- написать комментарий к решению
##### 1. Диаграмма прецедентов

![[usecase.png]]

##### 2. Диаграмма классов

?!

##### 3. Диаграмма состояний "Решения"

![[ало_состояния.png]]


## БД

#### 1. Библиотека

##### Общее

Минимальный список характеристик:
- Автор книги, название, год издания, цена, количество экземпляров, краткая аннотация;
- номер читательского билета, ФИО, адрес и телефон читателя, дата выдачи книги читателю и дата сдачи книги читателем, отметка о выбытии.

Книга имеет много экземпляров и поэтому может быть выдана многим читателям.

###### 0. БД

- Книга (айди, название, автор год, цена, кол, выдано)
- Выдача (дата выдачи, дата сдачи, дата сдачи факт, айди книги, айди читателя)
- Читатель (айди, ФИО, адрес, телефон)
###### 1. Выбрать читателей, которые имеют задолженность более 4 месяцев.

```PostgreSQL
select READER_ID, GAVE as shouldGave, GAVE_FACT as actualGave from Given
INNER JOIN Reader
ON Reader.ID = Given.READER_ID
where DATE_PART('month', GAVE_FACT) - DATE_PART('month', GAVE) > 4

SELECT Читатели.ФИО, Выдача.Дата_выдачи, Книги.Название FROM Читатели INNER JOIN (Книги INNER JOIN Выдача ON Книги.[Шифр книги] = Выдача.Щифр_книги) ON Читатели.Номер_билета = Выдача.Номер_билета WHERE (((DateDiff("m",[Выдача]![Дата_сдачи],Date()))>4) AND ((IsNull([Выдача]![Дата_сдачи_факт]))=Yes));
```
###### 2. Определить книгу, которая была наиболее популярной весной 2000 года..

```PostgreSQL
SELECT Книги.[Шифр книги], Count(Выдача.Дата_выдачи) AS [Count-Дата_выдачи], Книги.Автор, Книги.Название FROM Книги INNER JOIN Выдача ON Книги.[Шифр книги] = Выдача.Щифр_книги WHERE (((Выдача.Дата_выдачи) Between #3/1/2000# And #5/31/2000#)) GROUP BY Книги.[Шифр книги], Книги.Автор, Книги.Название;
```
###### 3. Определить читателей, у которых на руках находятся книги на общую сумму более 100 руб.

```PostgreSQL
SELECT Читатели.ФИО, Sum(Книги.Цена) AS [Sum-Цена] FROM Читатели INNER JOIN (Книги INNER JOIN Выдача ON Книги.[Шифр книги] = Выдача.Щифр_книги) ON Читатели.Номер_билета = Выдача.Номер_билета WHERE (((IsNull([Выдача]![Дата_сдачи_факт]))=Yes)) GROUP BY Читатели.ФИО HAVING (((Sum(Книги.Цена))>100));
```
###### 4. Выбрать книгу, для которой наибольшее количество экземпляров находится "на полках" (не выданы читателям).

```PostgreSQL
SELECT Max([Количество]-[Выдано]) AS [Не выдано]

FROM Книги;
```

#### 2. Университет

Минимальный список характеристик:
- Номер, ФИО, адрес и должность преподавателя, ученая степень;
- код, название, количество часов, тип контроля и раздел предмета (дисциплины);
- код, название, номер заведующего кафедрой;
- номер аудитории, где преподаватель читает свой предмет, дата, время, группа.

Один преподаватель может вести несколько дисциплин и одна дисциплина может вестись несколькими преподавателями.

Примечание: Циклы дисциплин: гуманитарный, общеинженерный, математический, компьютерный и т.д.

![[uni.jpeg]]

###### 1. Выбрать преподавателя, который был "без работы" весной 2001г.

```PostgreSQL
SELECT Преподаватели.ФИО 
FROM Преподаватели 
WHERE (
  (
  (Преподаватели.Номер) Not In 
    (SELECT Преподаватели.Номер 
    FROM Преподаватели 
    LEFT JOIN Расписание 
    ON Преподаватели.Номер = Расписание.Преподаватель 
    WHERE (
      ((Расписание.Дата) Between #3/1/2001# And #5/31/2001#)) 
    GROUP BY Преподаватели.Номер)
  )
);
```
###### 2. Определить возможные "накладки" аудиторий в расписании.

```PostgreSQL
SELECT Расписание.Дата, Расписание.Время, Расписание.Аудитория, Count(Расписание.[Код записи]) AS [Count-Код записи] 
FROM Расписание 
GROUP BY Расписание.Дата, Расписание.Время, Расписание.Аудитория 
HAVING (((Count(Расписание.[Код записи]))>1));
```
###### 3. Вывести расписание занятий группы 'АП-17а' на март 2001г.

```PostgreSQL
SELECT Расписание.Дата, Расписание.Время, Расписание.Аудитория, Расписание.Предмет, Расписание.Преподаватель 
FROM Группы 
INNER JOIN Расписание 
ON Группы.[Код группы] = Расписание.Группа 
WHERE (((Расписание.Дата) Between #3/1/2001# And #3/31/2001#) 
AND ((Группы.Название)="АП17а"));
```
###### 4. Определить для каждой группы долю дисциплин каждого цикла в процентах.

```PostgreSQL
-- 3. Определить, какой процент от общего объема дисциплин, изучаемых группой "ДИПРБ-31", 
-- составляют дисциплины для каждой категории
select count(*) / (
    select count(*) 
    from disciplines
)
from disciplices as d
         join groups_disciplines as gd on gd.discipline_id = d.id 
         join groups g on g.id = gd.group_id
         join group_codes gc on gc.id = g.group_code_id
where gc.name = "ДИПРБ" and 
      g.cource = 3
group by d.category_id;
```
#### 3. Сеть магазинов

Минимальный список характеристик:

- Номер, ФИО, адрес, телефон владельца магазина, размер вклада в магазин, номер регистрации, дата регистрации;
- номер, название, адрес и телефон магазина, уставной капитал, профиль;
- номер, ФИО, адрес, телефон поставщика, а также стоимость поставки данного поставщика в данный магазин.

Один и тот же магазин может иметь несколько владельцев и один и тот же владелец может иметь в собственности много магазинов.

Примечание: профиль - продуктовый, галантерейный, канцелярский и т.п.

![[shops.jpeg]]

###### 1. Определить самого молодого предпринимателя, владеющего собственностью в районе 'Киевский'.

```PostgreSQL
SELECT Owner.ID, Owner.Name, MAX(Owner.Birth)
FROM
(
SELECT Owner.Name, Owner.Birth, Shops.Area, COUNT(Shops.ID)
FROM Shops
INNER JOIN 
  (Ownings INNER JOIN Owner on Owner.Name = Owning.Owner_ID)
ON Shops.ID = Ownings.ID
GROUP BY Shops.Area, Owner.Name, Owner.Birth
HAVING ((Shops.Area) = 'Киевский')
)
GROUP BY Owner.ID, Owner.Name
```
###### 2. Определить случаи, когда регистрировалось владение лицами, не достигшими 18 лет.

```PostgreSQL
SELECT Owner.Name, Owner.Birth
FROM Owner
INNER JOIN 
 (Ownings INNER JOIN Shops on Ownings.Shop_ID = Shops.ID)
ON Ownings.Owner_ID = Owner.ID
WHERE (DATEPART('year', Owner.Birth) - DATEPART('year', GETDATE())) < 18
```