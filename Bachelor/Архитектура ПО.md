Программа подготовки к экзамену по дисциплине «Проектирование и архитектура автоматизированных систем»
> Источники:
> 1. Роберт Мартин - Чистая Архитектура (пункты 1, 3)
> 2. Мартин Фаулер - Шаблона Корпоративных Приложений (пункты 4)

## 1. Общие понятия
---
#### 1.1. Понятие об архитектуре. Цели архитектуры ПО, для чего она нужна. Что такое плохая и хорошая архитектура

=="**Архитектура программной системы** — это форма, которая придается системе ее создателями. Эта форма образуется делением системы на компоненты, их организацией и определением способов взаимодействий между ними. **Цель формы** — упростить разработку, развертывание и сопровождение про- граммной системы, содержащейся в ней . *Главная стратегия такого упрощения в том, чтобы как можно дольше иметь как можно больше вариантов*. Архитектура системы слабо влияет на работу системы . Существует масса систем с ужасной архитектурой, которые прекрасно работают. Главное предназначение архитектуры — поддержка жизненного цикла системы. Хорошая архитектура делает систему легкой в освоении, простой в разработке, сопровождении и развертывании . Конечная ее цель — минимизировать затраты на протяжении срока службы системы и максимизировать продуктивность программиста ." - Роберт Мартин==

**Архитектура программного обеспечения** – это представление, которое даёт информацию о компонентах ПО, обязанностях отдельных компонентов и правилах организации связей между компонентами. 

==*“Цель архитектуры программного обеспечения — уменьшить человеческие трудозатраты на создание и сопровождение системы. Мерой качества дизайна может служить простая мера трудозатрат, необ- ходимых для удовлетворения потребностей клиента . Если трудозатраты невелики и остаются небольшими в течение эксплуатации системы, систе- ма имеет хороший дизайн . Если трудозатраты увеличиваются с выходом каждой новой версии, система имеет плохой дизайн . Вот так все просто .”*  —  Роберт Мартин==

Необходимость архитектуры обоснована сложностью программного обеспечения. Продуманная архитектура облегчает разработку и дальнейшее развитие ПО. Она служит базисом, каркасом создаваемой системы, интегрируя отдельные компоненты и создавая высокоуровневую модель системы.

Набор принципов, используемых в архитектуре, формирует **архитектурный стиль**. Применение архитектурного стиля сродни употреблению шаблона проектирования, но не на уровне компонента, а на уровне всей создаваемой системы ПО. Как и шаблоны проектирования, архитектурные стили упрощают коммуникацию разработчиков и предлагают готовые решения целого класса абстрактных проблем.

**Плохая архитектура** (признаки):
1. Группа разработчиков не может назвать архитектора.
2. Количество компонентов верхнего уровня очень велико (больше 20).
3. Архитектура подгоняется под структуру организации.
4. Используются компоненты собственной разработки там, где могут использоваться готовые компоненты.
5. Одно требование ведет весь проект.
6. Архитектура зависит он специфики операционной системы.
7. Определение компонентов идет от используемой аппаратуры.
8. Имеется избыточность, не диктуемая надежностью.
9. Проектом движут исключения.

**Хорошая архитектура** упрощает тестирование, поддержку, модификацию, разработку и развертывание, а также обеспечивает независимость. Правильная архитектура преследует принципы:
* Прозрачность
* Общность
* Открытость
* Полнота
Уровень представления отвечает за взаимодействие с пользователем и обработку запросов. Уровень приложения выполняет бизнес-логику и координирует работу между уровнями представления и домена. Уровень домена содержит бизнес-логику и компоненты, отвечающие за работу с данными. Уровень инфраструктуры занимается поддержкой структур приложения и связью с внешними системами (например, базами данных, API и т.д.).

==*"Любой организации, занимающейся разработкой, лучше всего избегать самонадеянных решений и с самого начала со всей серьезностью отнестись к качеству архитектуры ее продукта.*" - Роберт Мартин==
#### 1.2. Понятие о логической архитектуры. Инструменты моделирования логической архитектуры системы

**Логическая архитектура** - это порядок организации и объединения логических компонентов системы. Логическая архитектура поддерживает функционирование системы на протяжении всего её жизненного цикла на логическом уровне. Она состоит из набора связанных технических концепций и принципов. Логическая архитектура представляется с помощью методов, соответствующих тематическим группам описаний, и как минимум, включает в себя функциональную архитектуру, поведенческую архитектуру и временную архитектуру.

Логическая архитектура включает действия, которые могут быть проделаны
независимо от условий, накладываемых средой исполнения, и в первую очередь направлены на удовлетворение функциональных требований. 

Некоторые из основных инструментов и методов проектирования эффективной архитектуры программного обеспечения включают в себя:
* **Унифицированный язык моделирования (UML).** UML — это стандартизированный язык визуального моделирования, используемый для создания диаграмм, дающих полное представление о структуре, поведении и взаимодействии между компонентами программного обеспечения. Это ценный инструмент для передачи архитектурного проекта заинтересованным сторонам и членам команды.
	UML предоставляет богатый набор типов диаграмм, в том числе:
	1. **Диаграмма вариантов использования:** представляет функциональные требования системы, иллюстрируя варианты использования, участников и их взаимодействие.
	2. **Диаграмма классов:** отображает статическую структуру системы, показывая классы, атрибуты, операции и отношения между ними.
	3. **Диаграмма объекта:** изображает объекты и их отношения в определенный момент времени.
	4. **Диаграмма последовательности:** визуализирует взаимодействие между объектами во времени, иллюстрируя последовательность вызовов методов и сообщений между ними.
	5. **Диаграмма сотрудничества:** представляет структуру и взаимодействие между объектами, показывая, как между ними происходит обмен сообщениями.
	6. **Диаграмма состояний:** фиксирует поведение объекта или системы, представляя его состояния, переходы и события, происходящие с течением времени.
	7. **Диаграмма действий:** моделирует поток управления в системе, показывая последовательность действий и решений, которые приводят к определенному результату.
	8. **Диаграмма компонентов:** изображает организацию и зависимости между повторно используемыми компонентами программного обеспечения.
	9. **Схема развертывания:** иллюстрирует физическое развертывание компонентов системы и их взаимоотношения в аппаратной среде.

Логическое представление включает продукты, которые определяют системные границы с её окружением и функциональные интерфейсы с внешними системами, также основные функции и поведение системы, потоки информации, внутренние и внешние наборы данных, внутренних и внешних пользователей, и внутренние функциональные интерфейсы. Примером продуктов могут быть 
* блочные диаграммы функциональных потоков
* контекстные диаграммы
* N²-диаграммы
* данные поточных диаграмм
* Диаграмма компонентов
* Диаграмма классов
### 1.3. Физическая архитектура. Инструменты моделирования физической архитектуры системы.

Цель проектирования физической архитектуры заключается в создании физического, конкретного решения, которое согласовано с логической архитектурой и удовлетворяет установленным системным требованиям.

После того, как логическая архитектура определена, должны быть идентифицированы конкретные физические элементы, которые поддерживают функциональные, поведенческие, и временные свойства, а также ожидаемые свойства системы, полученные из нефункциональных требований к системе.

Физическая архитектура является систематизацией физических элементов (элементов системы и физических интерфейсов), которые реализуют спроектированные решения для продукта, услуги или предприятия. Она предназначена для удовлетворения требований к системе и элементам логической архитектуры и реализуется через технологические элементы системы. Системные требования распределяются как на логическую, так и физическую архитектуру. Глобальная архитектура системы оценивается с помощью системного анализа и, после выполнения всех требований, становится основой для реализации системы
#### 1.4. Обзор структурной парадигмы программирования.

Структурное программирование было открыто Дейкстрой в 1968 году. Он понял, что goto – это зло, и программы должны строиться из трёх базовых структур: последовательности, ветвления и цикла он предложил заменить переходы более понятными конструкциями if/then/else и do/while/until. Он понял, что если в программах использовать только if, do, while, то тогда такие программы можно легко рекурсивно разделять на более мелкие единицы.

*Структурное программирование накладывает ограничение на прямую передачу управления и определяет программу как иерархическую структуру блоков*.

=="Дейкстра знал, что эти управляющие структуры (if/then/else и do/while - Модули, использующие только такие управляющие структуры, можно было рекурсивно разложить на доказуемые единицы .) в сочетании с последовательным выполнением занимают особое положение . Они были идентифицированы за два года до этого Бёмом и Якопини, доказавшими, что любую программу можно написать, используя всего три структуры: последовательность, выбор и итерации . Это было важное открытие: управляющие структуры, делающие доказуемой правильность модуля, в точности совпадали с набором структур, минимально необходимым для написания любой программы . Так родилось структурное программирование ." - Роберт Мартин== 
#### 1.5. Обзор объектно-ориентированной парадигмы программирования.

Второй парадигмой, получившей широкое распространение, стала парадигма появившаяся в 1966-м, и предложенная Далем и Нюгором . Эти два программиста заметили, что в языке ALGOL есть возможность переместить кадр стека вызова функции в динамическую память (кучу), благодаря чему локальные переменные, объявленные внутри функции, могут сохраняться после выхода из нее . В результате функция превращалась в ***конструктор класса***, локальные переменные — в ***переменные экземпляра***, а вложенные функции — в ***методы*** . Это привело к открытию полиморфизма через строгое использование указателей на функции.

*ООП подразумевает организацию программного кода, ориентируясь на данные и объекты, а не на функции и логические структуры.*

Четыре основных принципа объектно-ориентированного программирования:
- **Абстракция**. Моделирование требуемых атрибутов и взаимодействий сущностей в виде классов для определения абстрактного представления системы.
- **Инкапсуляция**. Скрытие внутреннего состояния и функций объекта и предоставление доступа только через открытый набор функций.
- **Наследование**. Возможность создания новых абстракций на основе существующих.
- **Полиморфизм**. Возможность реализации наследуемых свойств или методов отличающимися способами в рамках множества абстракций.
Определения:
- **Объекты** - **это** сущности, у которых есть свойства и поведение. Обычно **объекты** являются экземплярами какого-нибудь класса.
- **Класс** - это расширяемый шаблон программного кода для создания объектов, предоставляющий начальные значения состояния (переменные-члены) и реализации поведения (функции-члены или методы).

=="ОО дает, посредством поддержки полиморфизма, абсолютный контроль над всеми зависимостями в исходном коде . Это позволяет архитектору создать архитектуру со сменными модулями (плагинами), в которой модули верхнего уровня не зависят от модулей нижнего уровня . Низкоуровневые детали не выходят за рамки модулей плагинов, которые можно развертывать и разрабатывать независимо от модулей верхнего уровня." - Роберт Мартин== 
#### 1.6. Обзор функциональной парадигмы программирования.

Парадигма функционального программирования является прямым результатом работы Алонзо Чёрча, который в 1936 году изобрел лямбда-исчисление (или λ-исчисление), исследуя ту же математическую задачу, которая примерно в то же время занимала Алана Тьюринга . Его λ-исчисление легло в основу языка LISP, изобретенного в 1958 году Джоном Маккарти.

**Функциональное** **программирование**  —  это парадигма декларативного программирования, в которой программы создаются путем последовательного применения функций, которые не влияют на глобальный контекст всей программы.

Лямбда-исчисление является основой для функционального программирования, многие функциональные языки можно рассматривать как «надстройку» над ним.
## 2. Язык моделирования
---
#### 2.1 BPMN. Основные элементы BPMN-диаграммы и их назначение. Примеры.

На сегодняшний день BPMN является одним из самых распространенных методов описания бизнес-процессов, которые сегодня уже «понятны» как бизнес-пользователям, так и программным продуктам, предназначенным для работы с бизнес-моделями. Т.е. этот язык описания также является стандартом для создания исполняемых алгоритмов в управлении бизнесом.

BPMN (Business Process Model and Notation) - это язык моделирования бизнес-процессов, который является промежуточным звеном между формализацией/визуализацией и воплощением бизнес-процесса. С помощью моделирования мы можем описать любые бизнес-процессы, и они могут выполняться в самых разных системах управления.

Язык описания бизнес-процессов основан на следующих базовых объектах:

- **Event**

это событие, которое произошло в описании процесса. Эти события могут быть начальными, конечными или промежуточными.

![[Снимок экрана 2024-01-19 в 07.29.09.png]]

- **Activity** 

Это те действия (задачи), которые необходимо выполнить на определенном этапе бизнес-процесса. При моделировании их обычно обозначают прямоугольниками, что соответствует сути действия.

Действия могут быть элементарными, т. е. неделимыми на некоторые более простые действия, и неэлементарными, т. е. такими, которые при детализации распадаются на последовательность определенных более простых действий.

Обычно действия делятся следующим образом: **Задача** – единица работы. Если задача помечена символом +, то задача является подпроцессом и может быть детализирована; **Транзакция** – набор логически связанных действий. Для транзакции может быть определен протокол выполнения; **Вызывающее действие** является точкой входа для глобально определенного подпроцесса, который повторно используется в данном процессе.

- Gateway – Шлюзы или Развилки;

Это управляющий узел, который появляется при условном разветвлении бизнес-процесса. Графически изображается в виде ромба.

Шлюзы нужны и в тех случаях, когда процедура зависит от определенных факторов. Например, при работе с покупателями шлюз появляется на этапе, когда клиент принимает решение о покупке — «да или нет». При положительном решении необходимо совершить покупку, при отрицательном - выяснить возможные причины отказа, работать с "отказом" и т.д.

![[Снимок экрана 2024-01-19 в 07.31.48.png]]

- **Date** - Данные

Это элемент, указывающий, какие данные и документы необходимы для начала действия или каковы результаты завершенного действия.

Объект данных может быть сгенерированным заказом. Для менеджера это будет результат действий, а для склада, принимающего заказ, начало действия (сбор товара и отгрузка).

![[Снимок экрана 2024-01-19 в 07.33.21.png]]

- **Artefact** – Артефакты

Под артефактами в BPMN понимаются объекты, не являющиеся действиями и не имеющие прямого отношения к действиям. Это могут быть любые документы, данные, информация, не влияющие непосредственно на выполнение процесса.

Существует два типа артефактов:
- **_Группа объектов_** — это еще один способ объединить несколько элементов под общим символом, чтобы сэкономить место на диаграмме и упростить ее чтение. Здесь различные виды деятельности собраны под одним общим названием. Группа объектов также всегда может быть подробно рассмотрена. Группа выглядит как прямоугольник со скругленными углами, выполненный пунктирной линией с точками.
- **_Текстовые аннотации_** используются для различных уточнений к диаграмме. Это могут быть комментарии, пояснения, другая информация, которая повысит читабельность схемы. Аннотации представляют собой незамкнутый прямоугольник, выполненный сплошной линией, от которого к объекту аннотации ведет линия, состоящая из точек.

- **Pool** (Пул) 

Это объект, описывающий один процесс на диаграмме. Его может не быть на карте, но он всегда есть. На одной диаграмме может быть несколько Пулов. Пул может быть расширен для просмотра деталей.

Пул также может содержать так называемые «дорожки». Они нужны для того, чтобы указать участников процессов, которые скрыты в пуле. Например, в процессе работы с клиентами участвует менеджер по продажам, начальник отдела продаж, возможно, бухгалтер или кассир.

**Пример:** ![[Снимок экрана 2024-01-19 в 07.37.11.png]]
#### 2.2. Диаграммы вариантов использования. Основные элементы и их назначение.  Примеры.

**Диаграмма вариантов использования** (use case diagram) — диаграмма, на которой изображаются отношения между _акторами_ и _вариантами использования_ (_прецедентами_).

> Актор это калька с английского _Actor_ что расшифровывается как _действующее лицо_ (**Act** - действие, суффикс **-or** - человек, осуществляющий действие)

**Диаграмма вариантов использования** - это исходное концептуальное представление или концептуальная модель системы в процессе ее проектирования и разработки. Создание диаграммы вариантов использования имеет следующие цели:

- Определить общие границы и контекст моделируемой предметной области на начальных этапах проектирования системы
- Сформулировать общие требования к функциональному поведению проектируемой системы
- Разработать исходную концептуальную модель системы для ее последующей детализации в форме логических и физических моделей
- Подготовить исходную документацию для взаимодействия разработчиков системы с ее заказчиками и пользователями

Назначение данной диаграммы состоит в следующем: проектируемая информационная система представляется в форме так называемых _вариантов использования_, с которыми взаимодействуют внешние сущности или _акторы_. При этом _актором_ или действующим лицом называется любой объект, субъект или система, взаимодействующая с моделируемой бизнес-системой извне. Это может быть человек, техническое устройство, программа или любая другая система, которая служит источником воздействия на моделируемую систему так, как определит разработчик. _Вариант использования_ служит для описания сервисов, которые система предоставляет _актору_. Другими словами каждый _вариант использования_ определяет набор действий, совершаемый системой при диалоге с _актором_. При этом ничего не говорится о том, каким образом будет реализовано взаимодействие акторов с системой и собственно выполнение _вариантов использования_.

Рассматривая диаграмму _вариантов использования_ в качестве модели бизнес-системы, можно ассоциировать ее с "черным ящиком". Концептуальный характер этой диаграммы проявляется в том, что подробная детализация диаграммы или включение в нее элементов физического уровня представления на начальном этапе проектирования скорее имеет отрицательный характер, поскольку предопределяет способы реализации поведения системы. Эти аспекты должны быть сознательно скрыты от разработчика на диаграмме _вариантов использования_.

В самом общем случае, диаграмма _вариантов использования_ представляет собой граф специального вида, который является графической нотацией для представления конкретных _вариантов использования_, _акторов_ и отношений между этими элементами. При этом отдельные элементы диаграммы заключают в прямоугольник, который обозначает границы проектируемой системы. В то же время отношения, которые могут быть изображены на данном графе, представляют собой только фиксированные типы взаимосвязей между _акторами_ и _вариантами использования_, которые в совокупности описывают сервисы или функциональные требования к моделируемой системе.

Базовыми элементами диаграммы вариантов использования являются _вариант использования_ и _актор_.

**Вариант использования** (use case) — последовательность действий, которые система или другая сущность могут выполнять в процессе взаимодействия с _акторами_ (во многих источниках _вариант использования_ называют _прецедентом_, не надо пугаться и путаться - это одно и то же).

_Вариант использования_ представляет собой спецификацию общих особенностей поведения или функционирования моделируемой системы без рассмотрения внутренней структуры этой системы. Несмотря на то, что каждый вариант использования определяет последовательность действий, которые должны быть выполнены проектируемой системой при взаимодействии ее с соответствующим актором, сами эти действия не изображаются на рассматриваемой диаграмме.

Содержание _варианта использования_ может быть представлено в форме дополнительного пояснительного текста, который раскрывает смысл или семантику действий при выполнении данного _варианта использования_. Такой пояснительный текст получил название текста-сценария или просто сценария. Далее рассматривается один из шаблонов, который может быть рекомендован для написания сценариев вариантов использования.

Отдельный _вариант использования_ обозначается на диаграмме эллипсом, внутри которого содержится его краткое имя в форме **отглагольного существительного** с пояснительными словами. Сам **текст** имени варианта использования должен начинаться **с заглавной буквы**.

Цель _варианта использования_ заключается в том, чтобы зафиксировать некоторый аспект или фрагмент поведения проектируемой системы без указания особенностей реализации данной функциональности.

**Актор (actor)** — согласованное множество ролей, которые играют внешние сущности по отношению к _вариантам использования_при взаимодействии с ними.

_Актор_ представляет собой любую внешнюю по отношению к моделируемой системе сущность, которая взаимодействует с системой и использует ее функциональные возможности для достижения определенных целей или решения частных задач. Каждый _актор_ может рассматриваться как некая отдельная роль относительно конкретного варианта использования. Стандартным графическим обозначением актора на диаграммах является фигурка "человечка", под которой записывается имя актора

В языке UML имеется несколько стандартных видов отношений между акторами и вариантами использования:
- ассоциации (association relationship)
- включения (include relationship)
- расширения (extend relationship)
- обобщения (generalization relationship)

**Отношение ассоциации** – одно из фундаментальных понятий в языке UML и в той или иной степени используется при построении всех графических моделей систем в форме канонических диаграмм. Применительно к диаграммам _вариантов использования__ассоциация_ служит для обозначения специфической роли _актора_ при его взаимодействии с отдельным _вариантом использования_. На диаграмме вариантов использования _отношение ассоциации_ обозначается сплошной линией между _актором_ и _вариантом использования_. Эта линия может иметь некоторые дополнительные обозначения, например, _имя_ и _кратность_.

![[Снимок экрана 2024-01-19 в 06.18.38 1.png]]

В контексте диаграммы _вариантов использования_ **отношение ассоциации** между _актором_ и _вариантом использования_ может указывать на то, что _актор_ инициирует соответствующий _вариант использования_. Такого актора называют главным.

**Включение (include)** в языке UML — это разновидность отношения зависимости между базовым вариантом использования и его специальным случаем. При этом отношением зависимости (dependency) является такое отношение между двумя элементами модели, при котором изменение одного элемента (независимого) приводит к изменению другого элемента (зависимого).

Отношение включения устанавливается только **между двумя вариантами использования** и указывает на то, что заданное поведение для одного варианта использования включается в качестве составного фрагмента в последовательность поведения другого варианта использования.

![[Снимок экрана 2024-01-19 в 06.19.55.png]]

**Отношение расширения** (extend) определяет взаимосвязь базового варианта использования с другим вариантом использования, функциональное поведение которого задействуется базовым не всегда, а только при выполнении дополнительных условий.

В языке UML отношение расширения является зависимостью, направленной к базовому варианту использования и соединенной с ним в так называемой точке расширения. Отношение расширения между вариантами использования обозначается как отношение зависимости в форме пунктирной линии со стрелкой, направленной от того варианта использования, который является расширением для базового варианта использования. Данная линия со стрелкой должна быть помечена стереотипом "extend".

![[Снимок экрана 2024-01-19 в 06.21.02.png]]

**Пример:**
![[Снимок экрана 2024-01-19 в 06.21.35.png]]
#### 2.3. Диаграммы классов использования. Основные элементы и их назначение.  Примеры.

Центральное место в методологии ООАП занимает разработка логической модели системы в виде диаграммы классов. **Диаграмма классов** отражает, в частности, различные взаимосвязи между отдельными сущностями предметной области, такими как объекты и подсистемы, а также описывает их внутреннюю структуру и типы отношений. На данной диаграмме не указывается информация о временных аспектах функционирования системы. С этой точки зрения диаграмма классов может служить дальнейшим развитием концептуальной модели проектируемой системы

Диаграмма классов (class diagram) — диаграмма языка UML, на которой представлена совокупность декларативных или статических элементов модели, таких как классы с атрибутами и операциями, а также связывающие их отношения.

Диаграмма классов предназначена для представления статической структуры модели системы в терминологии классов объектно-ориентированного программирования.

Класс (class) — абстрактное описание множества однородных объектов, имеющих одинаковые атрибуты, операции и отношения с объектами других классов.

Графически класс в нотации языка UML изображается в виде прямоугольника, который дополнительно может быть разделен горизонтальными линиями на разделы или секции. В этих секциях могут указываться имя класса, атрибуты и операции класса.

![[Снимок экрана 2024-01-19 в 06.24.23.png]]

Интерфейс (interface) — именованное множество операций, которые характеризуют поведение отдельного элемента модели.

Интерфейс в контексте языка UML является специальным случаем класса, у которого имеются операции, но отсутствуют атрибуты. Для обозначения интерфейса используется специальный графический символ окружность или стандартный способ – прямоугольник класса со стереотипом `<<interface>>`.

![[Снимок экрана 2024-01-19 в 06.26.12 1.png]]

**Ассоциация** (association) - семантическое отношение между двумя и более классами, которое специфицирует характер связи между соответствующими экземплярами этих классов.

**Отношение ассоциации** соответствует наличию произвольного отношения или взаимосвязи между классами. Данное отношение, как уже отмечалось в лекции 3, обозначается сплошной линией со стрелкой или без нее и с дополнительными символами, которые характеризуют специальные свойства ассоциации. Ассоциации рассматривались при изучении элементов диаграммы вариантов использования, применительно к диаграммам классов, тем не менее, семантика этого типа отношений значительно шире. В качестве дополнительных специальных символов могут использоваться имя ассоциации, символ навигации, а также имена и кратность классов-ролей ассоциации.

![[Снимок экрана 2024-01-19 в 06.27.47 1.png]]
**Кратность** (multiplicity) — спецификация области значений допустимой мощности, которой могут обладать соответствующие множества.

Кратность атрибута характеризует общее количество конкретных атрибутов данного типа, входящих в состав отдельного класса. В общем случае кратность записывается в форме строки текста из цифр в квадратных скобках после имени соответствующего атрибута, при этом цифры разделяются двумя точками: [нижняя граница .. верхняя граница], где нижняя и верхняя границы положительные целые числа. Каждая такая пара служит для обозначения отдельного замкнутого интервала целых чисел, у которого нижняя (верхняя) граница равна значению нижней границы (верхней). В качестве верхней границы может использоваться специальный символ (звездочка), который означает произвольное положительное целое число, т.е. неограниченное сверху значение кратности соответствующего атрибута.

**Пример:**
![[Снимок экрана 2024-01-19 в 06.30.53 1.png]]

#### 2.4. Диаграммы последовательности. Основные элементы и их назначение.  Примеры.

Реализация отдельного варианта использования требует участия и взаимодействия определенных экземпляров актеров и классов. Наиболее подходящий инструмент для описания такого взаимодействия – это диаграммы последовательности и коммуникации, которые, по сути, отображают одну и ту же информацию. В связи с этим большинство Case-средств позволяет после построения одной из диаграмм автоматически получить другую, а также выполнять синхронизацию этих диаграмм между собой.

Общими элементами диаграмм являются:
- экземпляры актеров и объекты, участвующие во взаимодействии;
- сообщения, передаваемые между экземплярами актеров и объектами.

Взаимодействие между экземплярами актеров и объектами моделируется посредством передачи сообщений. Сообщение (англ. message) – это спецификация факта передачи информации между сущностями с ожиданием выполнения определенных действий со стороны принимающей сущности. Сущность, отправляющую сообщение, называют клиентом, а принимающую – сервером. Таким образом, сообщения не только передают некоторую информацию, но и требуют или предполагают выполнения сервером определенных действий или передачу (возврат) клиенту необходимой информации.

**Линия жизни** (англ. lifeline) отображается штриховой вертикальной линией, соединенной с соответствующим экземпляром сущности. Линия жизни служит для обозначения периода времени, в течение которого экземпляр может потенциально участвовать во взаимодействии. Если он существует в течение всего взаимодействия, то и его линия жизни должна продолжаться от самой верхней части диаграммы до самой нижней.

![[Снимок экрана 2024-01-19 в 06.33.45 1.png]]

Как было отмечено выше, взаимодействие между экземплярами моделируется через обмен **сообщениями**. Сообщения могут быть следующих видов:

[![](https://github.com/kolei/PiRIS/raw/master/img/uml_sequence_02.png)](https://github.com/kolei/PiRIS/blob/master/img/uml_sequence_02.png) – синхронное сообщение (англ. synchronous message). Клиент посылает сообщение серверу и **ждёт**, пока тот примет и обработает сообщение. Как правило, один объект передает синхронное сообщение второму, второй – третьему и т.д., образуя вложенный поток сообщений. В любом случае клиент, инициирующий поток сообщений, должен дождаться его завершения, т.е. возврата управления. Это самый распространенный тип сообщений;

[![](https://github.com/kolei/PiRIS/raw/master/img/uml_sequence_03.png)](https://github.com/kolei/PiRIS/blob/master/img/uml_sequence_03.png) – асинхронное сообщение (англ. asynchronous message). Клиент посылает сообщение серверу и, не дожидаясь ответа, продолжает выполнять следующие операции;

[![](https://github.com/kolei/PiRIS/raw/master/img/uml_sequence_04.png)](https://github.com/kolei/PiRIS/blob/master/img/uml_sequence_04.png) – возвращающее сообщение (англ. reply message), обозначающее возврат значения или управления от сервера обратно клиенту. Стрелки этого вида зачастую отсутствуют на диаграммах, поскольку неявно предполагается их существование после окончания процесса выполнения операции.

Отправка и прием сообщений сопровождаются активностью объектов. Для явного выделения этого факта, на диаграмме можно использовать **фокус управления** (англ. focus of control). Он изображается в форме вытянутого узкого прямоугольника, верхняя сторона которого обозначает начало получения фокуса управления объекта (начало активности), а нижняя сторона – окончание фокуса управления (окончание активности).

![[Снимок экрана 2024-01-19 в 06.34.57 1.png]]
Для моделирования особенностей взаимодействия (условных операторов, циклов и т.п.) вместо вложенных фокусов управления лучше использовать **фрагменты** (англ. fragments). Фрагмент отображается прямоугольной рамкой вокруг сообщения (группы сообщений) с указанием в левом верхнем углу типа фрагмента.

![[Снимок экрана 2024-01-19 в 06.35.34 1.png]]

UML определяет следующие типы фрагментов:

- alt (alternatives) - вызовы альтернативных сообщений (выполнение взаимоисключающих операций). Альтернативные сообщения (группы сообщений) отделяются друг от друга горизонтальными штриховыми линиями. Используется для моделирования условного оператора (if-then-else) и операторов выбора (case или switch);
- opt (option) - вызов дополнительного сообщения (группы сообщений) при некотором условии. Аналогичен фрагменту с типом «alt» для случая, когда используется сокращенный условный оператор (if-then);
- par (parallel) - параллельная обработка сообщений. Параллельно обрабатываемые сообщения (группы сообщений) отделяются друг от друга горизонтальными штриховыми линиями;
- loop - циклическая обработка сообщений. Используется для моделирования циклов;
- break - досрочное прерывание обработки сообщений при некотором условии. Используется как составная часть других фрагментов (как правило, «loop»);
- critical - эксклюзивно обрабатываемое сообщение (группа сообщений). Используется как составная часть других фрагментов (как правило, «par»). Подразумевает приостановку обработки любых сообщений в более общем фрагменте на время обработки сообщений внутри подфрагмента «critical»;
- neg (negative) - сообщение или событие, сгенерированное в результате невозможности обработки другого принятого сообщения. Например, если при запросе пароля getPassword() истекло время на его ввод, то вместо возврата пароля будет сгенерировано сообщение «время вышло» (англ. «timeout»);
- assert (assertion) - сообщение (группа сообщений), выполняемое после предварительной проверки некоторого условия. Если условие отрицательно, то сообщение не посылается. В программировании такой прием часто используется для локализации ошибок;
- strict - строгая последовательная обработка сообщений. Последовательно обрабатываемые сообщения (группы сообщений) отделяются друг от друга горизонтальными штриховыми линиями и обрабатываются строго по очереди сверху-вниз;
- seq (sequencing) - нестрогая последовательная обработка сообщений. Сообщения (группы сообщений) отделяются друг от друга горизонтальными штриховыми линиями и могут обрабатываться в произвольном порядке за исключением сообщений, принимаемых одним объектом;
- ignore - игнорирование сообщений. После слова «ignore» в фигурных скобках перечисляются сообщения, возникновение которых во фрагменте потенциально возможно наряду с явно отображенными и которые должны быть проигнорированы;
- consider - игнорирование других сообщений. После слова «consider» в фигурных скобках перечисляются сообщения, которые явно отображены во фрагменте, а также возникновение которых во фрагменте потенциально возможно наряду с явно отображенными. Остальные потенциально возможные сообщения должны быть проигнорированы;
- ref (reference) - ссылка на часть взаимодействия, определенную в другом месте (на другой диаграмме). Данный элемент подобен предопределенным процессам на блок-схемах или скрытым составным состояниям на диаграммах автоматов.

**Пример:**
![[Снимок экрана 2024-01-19 в 06.37.33 1.png]]
#### 2.5. Диаграммы состояний. Основные элементы и их назначение.  Примеры.

Под **состоянием** (англ. state) понимается ситуация в ходе жизни экземпляра сущности, когда эта ситуация удовлетворяет некоторому условию, экземпляр выполняет некоторые операции или ждет наступления некоторого события. Например, для объекта его состояние может быть задано в виде набора конкретных значений атрибутов, при этом изменение этих значений будет приводить к изменению состояния моделируемого объекта.

В UML различают два вида операций: действие и деятельность. **Действие** (англ. action) – это атомарная операция, выполнение которой не может быть прервано, приводящая к смене состояния или возвращающая значение. Примерами действий служат операции создания или уничтожения объекта, расчет факториала и т.д. **Деятельность** (англ. activity) – это составная (неатомарная) операция, реализуемая экземпляром в конкретном состоянии, выполнение которой может быть прервано. В частности, под деятельностью можно понимать процедуры расчета допускаемых скоростей или шифрования данных.

**Событие** (англ. event) – это спецификация существенного факта, который может произойти в конкретный момент времени. События могут быть внутренними или внешними. Внешние события передаются между системой и актерами (например, нажатие кнопки или посылка сигнала от датчика передвижений). Внутренние события передаются между объектами внутри системы. В UML можно моделировать следующие виды событий:
- посылка сообщения (англ. message):
    - вызов (англ. call);
    - сигнал (англ. signal);
    - любое сообщение (англ. any receive);
- событие времени (англ. time);
- изменение состояния (англ. change).

**Вызов** – спецификация факта посылки синхронного сообщения между объектами, предписывающего выполнение операции (действия или деятельности) объектом, которому посылается сообщение. Синхронность означает, что после посылки вызова объект-отправитель передает управление объекту-получателю и после выполнения последним операции получает управление обратно. Например, закрасить фигуру красным фоном fill(red) или рассчитать допускаемые скорости calculateVdop().

**Сигнал** – спецификация факта посылки асинхронного сообщения между объектами. Исключения, которые поддерживаются в большинстве современных языков программирования, являются наиболее распространенным видом внутренних сигналов.

**Событие времени** – спецификация факта, обозначающего наступление конкретного момента времени (англ. absolute time) или истечение определенного промежутка времени (англ. relative time). В UML данный факт обозначается с помощью ключевых слов «at» (например, at 9:00:00) и «after» (например, after 2 seconds).

**Изменение состояния** – спецификация логического условия, соответствующего изменению состояния экземпляра сущности. В UML оно обозначается с помощью ключевого слова «when» (например, when A < B) или сторожевого условия (например, [A < B]).

Состояние отображается в виде четырехугольника со скругленными углами, внутри которого обязательно записывается имя. Рекомендуется в качестве имени использовать глаголы в настоящем времени (звенит, печатает, ожидает) или причастия (занято, передано, получено).

![[Снимок экрана 2024-01-19 в 06.39.36 1.png]]

Характеристика состояния может содержать описание выполняемых операций, перед которыми указывается одна из стандартных **меток**:
- entry (англ. – вход) – действие при входе, выполняемое вне зависимости от того, по какому переходу был выполнен вход в состояние. Например, создать соединение с базой данных entry / createConnect();
- exit (англ. – выход) – действие при выходе, выполняемое вне зависимости от того, по какому переходу был выполнен выход из состояния. Например, закрыть соединение с базой данных exit / closeConnect();
- do (англ. – выполнять) – деятельность в состоянии. Находясь в состоянии, экземпляр сущности может бездействовать и ждать наступления некоторого события, а может выполнять длительную операцию. Например, рассчитать допускаемые скорости do / calculateVdop(). Допускается указывать несколько операций в виде отдельных строк, каждая из которых начинается с метки «do», или в виде одной строки, операции в которой отделены друг от друга точкой с запятой.

**Переход** (англ. transition) – отношение между двумя состояниями, показывающее возможный путь изменения состояния экземпляра сущности. Считается, что в состоянии экземпляр сущности находится продолжительное время, а переход выполняется мгновенно.

Переход отображается в виде однонаправленной ассоциации между двумя состояниями. При смене состояний говорят, что переход срабатывает. До срабатывания перехода экземпляр сущности находится в состоянии, называемом **исходным**, а после его срабатывания – в **целевом**. Различают два вида переходов: **нетриггерный** и **триггерный**.

**Пример:**

![[Снимок экрана 2024-01-19 в 06.41.50 1.png]]
#### 2.6. Диаграммы активности. Основные элементы и их назначение.  Примеры.
#### 2.7. Диаграммы компонентов. Основные элементы и их назначение.  Примеры.
#### 2.8. Диаграммы развертывания. Основные элементы и их назначение.  Примеры.

## 3. Архитектурные принципы
---
#### 3.1. Общая характеристика принципов SOLID.

**Принципы SOLID** определяют, как объединять функции и структуры данных в классы и как эти классы должны сочетаться друг с другом . Использование слова «класс» не означает, что эти принципы применимы только к объектно-ориентированному программному коду . В данном случае ***«класс»*** означает лишь *инструмент объединения функций и данных в группы. Любая программная система имеет такие объединения, как бы они ни назывались, «класс» или как-то еще . Принципы SOLID применяются к этим объединениям .

Цель принципов — создать программные структуры среднего уровня, которые:
-  терпимы к изменениям;
-  просты и понятны;
-  образуют основу для компонентов, которые могут использоваться во многих программных системах .

Термин *«средний уровень»* отражает тот факт, что эти принципы применяются программистами на уровне модулей.

Краткое описание:
- **SRP: Single Responsibility Principle** — принцип единственной ответственности.
	Действительное следствие закона Конвея: лучшей является такая структура программной системы, которая формируется в основном под влиянием социальной структуры организации, использующей эту систему, поэтому каждый программный модуль имеет одну и только одну причину для изменения .
- **OCP: Open-Closed Principle** — принцип открытости/закрытости. 
	Суть его сводится к следующему: простая для изменения система должна предусматривать простую возможность изменения ее поведения добав- лением нового, но не изменением существующего кода.
- **LSP: Liskov Substitution Principle** — принцип подстановки Барбары Лисков.
	В двух словах, этот принцип утверждает, что для создания программных систем из взаимозаменяемых частей эти части должны соответствовать контракту, который позволяет заменять эти части друг другом .
- **ISP: Interface Segregation Principle** — принцип разделения интерфейсов. 
	Этот принцип призывает разработчиков программного обеспечения избегать зависимости от всего, что не используется.  
- **DIP: Dependency Inversion Principle** — принцип инверсии зависимости. 
	Код, реализующий высокоуровневую политику, не должен зависеть от кода, реализующего низкоуровневые детали . Напротив, детали должны зависеть от политики .
#### 3.2. Принцип единственной ответственности. Примеры 

=="*...Более правильным выглядит понятие группы, состоящей из одного или нескольких лиц, желающих данного изменения . Мы будем называть такие группы акторами (actor). Соответственно, окончательная версия принципа единственной ответственности выглядит так: **Модуль должен отвечать за одного и только за одного актора**.*" - Роберт Мартин==

**Признаки нарушения принципа:** 

1. **Непреднамеренное дублирование**

Мой любимый пример — класс Employee из приложения платежной ведомости . Он имеет три метода: calculatePay(), reportHours() и save()
  ![[Снимок экрана 2024-01-18 в 22.51.24.png]]
Этот класс нарушает принцип единственной ответственности, потому что три его метода отвечают за три разных актора:
- Реализация метода calculatePay() определяется бухгалтерией .
- Реализация метода reportHours() определяется и используется отделом по работе с персоналом .
- Реализация метода save() определяется администраторами баз данных .

1. **Слияния**

Слияния — обычное дело для исходных файлов с большим количеством разных методов. Эта ситуация особенно вероятна, если эти методы отвечают за разных акторов.

Например, представим, что коллектив администраторов баз данных решил внести простое исправление в схему таблицы Employee. Представим также, что сотрудники отдела по работе с персоналом пожелали немного изменить формат отчета, возвращаемого функцией reportHours() .

Два разных разработчика, возможно, из двух разных команд, извлекли класс Employee из репозитория и внесли изменения . К сожалению, их изменения оказались несовместимыми . В результате потребовалось вы- полнить слияние .

**Решение п.1 и п.2:**
Существует много решений этой проблемы . Но каждое связано с перемещением функций в разные классы .

Наиболее очевидным, пожалуй, является решение, связанное с отделением данных от функций . Три класса, как показано на рис . 7 .3, используют общие данные EmployeeData — простую структуру без методов . Каждый класс вклю- чает только исходный код для конкретной функции . Эти три класса никак не зависят друг от друга . То есть любое непреднамеренное дублирование исключено .

Недостаток такого решения — разработчик теперь должен создавать экземпляры трех классов и следить за ними . Эта проблема часто решается применением шаблона проектирования «Фасад» (Facade), как показано на рис . 7 .4
![[Снимок экрана 2024-01-18 в 22.57.45.png]]

**Заключение**: *принцип единственной ответственности* касается функций и классов, но он проявляется в разных формах на еще двух более высоких уровнях . На уровне компонентов он превращается в принцип согласованного изменения (Common Closure Principle; CCP), а на архитектурном уровне — в принцип оси изменения (Axis of Change), отвечающий за создание архитектурных границ .
#### 3.3.Принцип открытости / закрытости. Примеры.

==" Принцип открытости/закрытости гласит: *Программные сущности должны быть открыты для расширения и закрыты для изменения.* Иными словами, должна иметься возможность расширять поведение программных сущностей без их изменения. Очевидно, если простое расширение требований ведет к значительным изменениям в программном обеспечении, значит, архитекторы этой программной системы потерпели сокрушительное фиаско . " - Роберт Мартин==

**Пример**:
Представьте, что у нас есть *финансовая сводка*. Содержимое страницы прокручивается, и *отрицательные значения выводятся красным цветом*. Теперь допустим, что заинтересованные лица попросили нас представить ту же информацию в виде отчета, распечатанного на черно-белом принтере, разбит на страницы... *Отрицательные значения должны заключаться в круглые скобки*. 

Очевидно, что для этого придется написать новый код . Но *как много старого кода придется изменить*? В программном обеспечении с хорошо проработанной архитектурой таких изменений должно быть *очень немного*. 

Самое важное, что нужно понять - в данном примере в создание отчета вовлечены две отдельные ответственности: *вычисление данных для отчета* и *представление этих данных в форме веб-отчета*. Мы должны организовать зависимости так, чтобы изменения в одной из ответственностей не вызывали необходимости изменений в другой. Новая организация должна гарантировать возможность расширения поведения без отмены изменений. Этого можно добиться, выделив процессы в классы, а классы в компоненты: **контроллер**, **интерактор** или **посредник**, **база данных**,**презентаторы** и **представления**.

![[Снимок экрана 2024-01-18 в 23.19.36.png]]

=="Позволю себе повторить еще раз: если компонент A требуется защитить от изменений в компоненте B, компонент B должен зависеть от компонента A ." - Роберт Мартин==

![[Снимок экрана 2024-01-18 в 23.21.23 1.png]]
Обратите внимание, что в результате выстраивается *иерархия защиты*, основанная на понятии «уровня» . **Интеракторы** занимают самый верхний уровень, поэтому они должны быть самыми защищенными . **Представления** занимают самый низкий уровень, поэтому они наименее защищены . **Презентаторы** находятся уровнем выше представлений, но ниже контроллера или интерактора .

Именно так работает **принцип открытости/закрытости** на архитектурном уровне. Архитекторы разделяют функциональные возможности, опираясь на то, как, почему и когда их может потребоваться изменить, и затем организуют их в иерархию компонентов . Компоненты, находящиеся на верхних уровнях в такой иерархии, защищаются от изменений в компонентах на нижних уровнях.

**Заключение:** *принцип открытости/закрытости* — одна из движущих сил в архитектуре систем . Его цель — сделать систему легко расширяемой и обезопасить ее от влияния изменений . Эта цель достигается делением системы на компоненты и упорядочением их зависимостей в иерархию, защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже .
#### 3.4. Принцип подстановки Лискоу. Примеры.

==" В 1988 году Барбара Лисков написала следующие строки с формулировкой определения подтипов: *Здесь требуется что-то вроде следующего свойства подстановки: если для каждого объекта o1 типа S существует такой объект o2 типа T, что для всех программ P, определенных в терминах T, поведение P не изменяется при подстановке o1 вместо o2, то S является подтипом T1*." - Роберт Мартин ==

**Пример**:
Представьте, что у нас есть класс с именем **License**, как показано на рис . 9 .1 . Этот класс имеет метод с именем **calcFee**(), который вызывается приложением **Billing** . Существует два «подтипа» класса **License**: **PersonalLicense** и **BusinessLicense** . Они реализуют разные алгоритмы расчета лицензионных отчислений.
![[Снимок экрана 2024-01-18 в 23.26.50.png]]

Этот дизайн соответствует принципу подстановки Барбары Лисков, потому что поведение приложения Billing не зависит от использования того или иного подтипа . Оба подтипа могут служить заменой для типа License.

**Примеры нарушения принципа**:

1. Квадрат

Классическим примером нарушения принципа подстановки Барбары Лисков может служить известная проблема квадрат/прямоугольник.
![[Снимок экрана 2024-01-18 в 23.29.47.png]]

В этом примере класс **Square** (представляющий квадрат) неправильно определен как подтип класса **Rectangle** (представляющего прямоугольник), потому что *высоту и ширину прямоугольника можно изменять независимо*; а *высоту и ширину квадрата можно изменять только вместе*. Поскольку класс User полагает, что взаимодействует с экземпляром Rectangle, его легко можно ввести в заблуждение.

**Заключение**: *принцип подстановки Барбары Лисков* может и должен распространяться до уровня архитектуры . Простое нарушение совместимости может вызвать загрязнение архитектуры системы значительным количеством дополни- тельных механизмов .
#### 3.5. Принцип разделения интерфейсов. Примеры.

**Пример**:
![[Снимок экрана 2024-01-18 в 23.40.53.png]]

В данной ситуации имеется несколько классов, пользующихся операциями в классе OPS . Допустим, что User1 использует только операцию op1, User2 — только op2 и User3 — только op3. Очевидно, что в такой ситуации исходный код User1 непреднамеренно будет зависеть от op2 и op3, даже при том, что он не пользуется ими . Эта за- висимость означает, что изменения в исходном коде метода op2 в классе OPS потребуют повторной компиляции и развертывания класса User1, несмотря на то что для него ничего не изменилось.

Эту проблему можно решить разделением операций по интерфейсам.
![[Снимок экрана 2024-01-18 в 23.41.54.png]]

Если снова представить, что этот интерфейс реализован на языке со строгим контролем типов, таком как Java, исходный код User1 будет зависеть от U1Ops и op1, но не от OPS . То есть изменения в OPS, которые не касаются User1, не потребуют повторной компиляции и развертывания User1.

Очевидно, что описание выше в значительной степени зависит от *типа языка* . Языки со **статическими** типами, такие как Java, вынуждают про- граммистов создавать объявления, которые должны импортироваться или подключаться к исходному коду пользователя как-то иначе . Именно эти инструкции подключения в исходном коде пользователя создают зависи- мости и вынуждают выполнять повторную компиляцию и развертывание .

В языках с **динамической** типизацией, таких как Ruby или Python, по- добные объявления отсутствуют в исходном коде — они определяются автоматически во время выполнения . То есть в исходном коде отсутствуют зависимости, вынуждающие выполнять повторную компиляцию и развер- тывание . Это главная причина, почему системы на языках с динамической типизацией получаются более гибкими и с меньшим количеством строгих связей .

*Этот факт ведет нас к заключению, что принцип разделения интерфейсов является проблемой языка, а не архитектуры.*

**Нарушение**:
Рассмотрим, например, действия архитектора, работающего над системой S . Он пожелал включить в систему некоторый фреймворк F . Теперь представь- те, что авторы F связали его с поддержкой конкретной базы данных D . То есть S зависит от F, который зависит от D (рис . 10 .3) .
![[Снимок экрана 2024-01-18 в 23.45.33.png]]

Теперь представьте, что D включает функции, которые не используются фреймворком F и, соответственно, не используются системой S . Изменения в этих функциях внутри D могут вынудить повторно развернуть F и, со- ответственно, повторно развернуть S . Хуже того, ошибка в одной из таких функций внутри D может спровоцировать появление ошибок в F и S.

**Заключение**: зависимости, несущие лишний груз ненужных и неиспользуемых особенностей, могут стать причиной неожи- данных проблем. Мы развернем эту мысль подробнее при обсуждении принципа совместно- го использования (Common Reuse Principle; CRP) в главе 13 «Связность компонентов» .
#### 3.6. Принцип инверсии зависимостей. Примеры.

=="Принцип инверсии зависимости (Dependency Inversion Principle; DIP) ут- верждает, что наиболее *гибкими* получаются системы, в которых *зависимости* в исходном коде направлены на *абстракции*, а не на *конкретные реализации*." - Роберт Мартин==

В языках со *статической системой типов*, таких как Java, это означает, что инструкции use, import и include должны ссылаться только на модули с исходным кодом, содержащим интерфейсы, абстрактные классы и другие абстрактные объявления . Никаких зависимостей от конкретных реализаций не должно быть .

То же правило действует для языков с *динамической системой типов*, таких как Ruby или Python . Исходный код не должен зависеть от модулей с кон- кретной реализацией . Однако в этих языках труднее определить, что такое конкретный модуль . В частности, это любой модуль, в котором реализованы вызываемые функции .

Очевидно, что принять эту идею за правило практически невозможно, потому что программные системы должны зависеть от множества конкретных особенностей . Например, String в Java — это конкретный класс и его невозможно сделать абстрактным . Зависимости исходного кода от конкретного модуля java.lang.string невозможно и не нужно избегать. *Программистам и архитекторам не приходится беспокоиться о частых и непредсказуемых изменениях в String.* *Мы терпим эти конкретные зависимости, потому что уверенно можем положиться на их постоянство.*

Мы должны избегать зависимости от неустойчивых конкретных элементов системы . То есть от модулей, которые продолжают активно разрабатываться и претерпевают частые изменения.

1. Стабильные абстракции

**Стабильными называются такие архитектуры**, в которых вместо зависимостей от переменчивых конкретных реализаций используются зависимости от *стабильных* абстрактных интерфейсов . Это следствие сводится к набору очень простых правил:
- **Не ссылайтесь на изменчивые конкретные классы.** Ссылайтесь на абстрактные интерфейсы . Это правило применимо во всех языках, не- зависимо от устройства системы типов . Оно также накладывает важные ограничения на создание объектов и определяет преимущественное ис- пользование шаблона «Абстрактная фабрика» .
- **Не наследуйте изменчивые конкретные классы** . Это естественное след- ствие из предыдущего правила, но оно достойно отдельного упоминания . Наследование в языках со статической системой типов является самым строгим и жестким видом отношений в исходном коде; следовательно, его следует использовать с большой осторожностью . Наследование в языках с динамической системой типов влечет меньшее количество проблем, но все еще остается зависимостью, поэтому дополнительная предосторожность никогда не помешает .
- **Не переопределяйте конкретные функции**. Конкретные функции часто требуют зависимостей в исходном коде . Переопределяя такие функции, вы не устраняете эти зависимости — фактически вы наследуете их . Для управления подобными зависимостями нужно сделать функцию абстрактной и создать несколько ее реализаций .
- **Никогда не ссылайтесь на имена конкретных и изменчивых сущностей.** В действительности это всего лишь перефразированная форма самого принципа .

2. Фабрики

Чтобы соблюсти все эти правила, необходимо предусмотреть особый способ создания изменчивых объектов. В большинстве объектно-ориентированных языков, таких как Java, для управления подобными нежелательными зависимостями можно использовать шаблон *«Абстрактная фабрика»*.

Рисунок демонстрирует, как работает такая схема . Приложение *Application* использует конкретную реализацию *ConcreteImpl* через интерфейс *Service* . Однако приложению требуется каким-то образом создавать экземпляры *ConcreteImpl* . Чтобы решить эту задачу без образования зависимости от *ConcreteImpl* на уровне исходного кода, приложение вызывает метод *makeSvc* интерфейса фабрики *ServiceFactory* . Этот метод реализован в классе *ServiceFactoryImpl*, наследующем *ServiceFactory* . Эта реализация создает экземпляр *ConcreteImpl* и возвращает его как экземпляр интерфейса *Service*.

![[Снимок экрана 2024-01-19 в 01.19.08.png]]

Извилистая линия делит систему на два компонента: **абстрактный** и **конкретный** . Абстрактный компонент содержит все высокоуровневые бизнес- правила приложения . Конкретный компонент содержит детали реализации этих правил.

3. Конкретные компоненты

Конкретный компонент *ConcreteImpl* на рис . 11 .1 имеет единственную зависимость, то есть он нарушает принцип DIP. Это нормально. Полностью устранить любые нарушения принципа инверсии зависимости невозможно, но их можно сосредоточить в узком круге конкретных компонентов и изолировать от остальной системы .

Большинство систем будет содержать хотя бы один такой конкретный ком- понент — часто с именем main, потому что включает функцию main

**Заключение**: принцип , суть которого состоит в том, что классы должны зависеть от абстракций, а не от конкретных деталей. Используется для минимизации *зацепления* (сила взаимосвязей между модулями; мера того, насколько взаимозависимы разные подпрограммы или модули) в компьютерных программах. Может рассматриваться как уменьшение знаний о данных и поведении объекта (и зацепления с ним) до минимума, описанного интерфейсом.
#### 3.7. Принцип эквивалентности повторного использования и выпусков. Примеры.

=="Единица повторного использования есть единица выпуска." - Роберт Мартин==

С точки зрения архитектуры и дизайна этот принцип означает, что *классы и модули, составляющие компонент, должны принадлежать связной группе*. Компонент не может просто включать случайную смесь классов и модулей; должна быть какая-то тема или цель, общая для всех модулей.

Все это, безусловно, очевидно. Однако есть еще один аспект, возможно, не такой очевидный. Классы и модули, объединяемые в компонент, должны *выпускаться вместе*. Объединение их в один выпуск и включение в общую документацию с описанием этой версии должны иметь смысл для автора и пользователей.
#### 3.8. Принцип согласованного изменения. Примеры.

=="В один компонент должны включаться классы, изменяющиеся по одним причинам и в одно время. В разные компоненты должны включаться классы, изменяющиеся в разное время и по разным причинам." - Роберт Мартин==

Это принцип единственной ответственности (SRP), перефразированный для компонентов. Так же, как принцип SRP, гласящий, что класс не должен иметь нескольких причин для изменения, принцип согласованного изменения (CCP) требует, чтобы *компонент* не имел нескольких причин для изменения.

Принцип CCP требует от нас собирать вместе все классы, которые может понадобиться изменить по одной, общей причине. Если два класса тесно связаны, физически или концептуально, настолько, что всегда будут изменяться вместе, *они должны принадлежать одному компоненту*.

Этот принцип тесно связан с **принципом открытости/закрытости** (Open Closed Principle; OCP) . Фактически он означает «*закрытость*» в смысле принципа OCP. **Принцип открытости/закрытости** (OCP) требует, чтобы классы были закрыты для изменений, но открыты для расширения. Так как 100% закрытость невозможна, она должна носить скорее *стратегический* характер . Мы проектируем свои классы так, чтобы они были закрыты для изменений, наиболее типичных из ожидаемых по опыту .

**Принцип согласованного изменения** (CCP) развивает эту идею, предписывая объединять в один компонент только классы, *закрытые для одного и того же вида изменений*. То есть увеличивает вероятность, что изменение требований повлечет необходимость изменения минимального количества компонентов.

Как отмечалось выше, **принцип согласованного изменения** (CCP) есть форма **принципа единственной ответственности** (SRP) для компонентов. Принцип SRP требует выделять методы в разные классы, если они изменяются по разным причинам.

Принцип CCP аналогично требует выделять классы в разные компоненты, если они изменяются по разным причинам. Оба принципа можно привести к общей формуле: *Собирайте вместе все, что изменяется по одной причине и в одно время. Разделяйте все, что изменяется в разное время и по разным причинам.*
#### 3.9. Принцип совместного повторного использования. Примеры.

=="Не вынуждайте пользователей компонента зависеть от того, чего им не требуется." - Роберт Мартин==

**Принцип совместного повторного использования** (Common Reuse Principle; CRP) — еще один принцип, помогающий определять, какие классы и модули должны включаться в компонент. Он указывает, что в компонент должны включаться классы и модули, используемые совместно.

Классы редко используются по отдельности. Обычно многократно используемые классы взаимодействуют с другими классами, являющимися частью многократно используемой абстракции. Принцип CRP указывает, что такие классы должны включаться в один компонент. Мы надеемся увидеть в компонентах классы, имеющие множественные зависимости друг от друга.

**Пример**: простейшим примером могут служить класс *коллекции* и связанные с ним *итераторы* . Эти классы используются вместе, потому что они тесно связаны друг с другом . Соответственно, должны находиться в одном компоненте .

Классы, включаемые в компонент, должны быть неотделимы друг от друга — чтобы нельзя было зависеть от одних и не зависеть от других . Иначе нам придется повторно развертывать больше компонентов, чем требуется, и тратить су- щественно больше усилий.

**Принцип совместного повторного использования** (CRP) является обобщенной версией **принципа разделения интерфейсов** (ISP) . Принцип ISP советует не создавать зависимостей от классов, методы которых не используются . Принцип CRP советует не создавать зависимостей от компонентов, имеющих неиспользуемые классы. Обобщая, эти советы можно объединить в один: *Не создавайте зависимостей от чего-либо неиспользуемого.*

**Заключение**: **принцип совместного повторного использования** (CRP) в большей степени говорит о том, какие классы не должны объединяться, чем какие должны объединяться . Принцип CRP указывает, что классы, не имеющие тесной связи, не должны включаться в один компонент.

#### 3.X Противоречие принципов связности компонентов (3.7, 3.8, 3.9)

Возможно, вы уже заметили, что три принципа связности компонентов вступают в противоречие друг с другом. Принципы **эквивалентности повторного использования** (REP) и **согласованного изменения** (CCP) являются *включительными*: оба стремятся сделать компоненты как можно крупнее. **Принцип повторного использования** (CRP) — *исключительный*, стремящийся сделать компоненты как можно мельче. Задача хорошего архитектора — разрешить это противоречие.

На рис изображена диаграмма противоречий, показывающая, как три принципа связности влияют друг на друга. Ребра на диаграмме описывают цену нарушения принципа на противоположной вершине.

Архитектор, уделяющий внимание только принципам REP и CRP, обнаружит, что простое изменение вовлекает *слишком большое количество компонентов* . С другой стороны, архитектор, уделяющий особое внимание принципам CCP и REP, вынужден будет выпускать *слишком много ненужных версий*.

![[Снимок экрана 2024-01-19 в 01.45.43.png]]

**Заключение**: выбирая классы для включения в компоненты, нужно учитывать противодействующие силы, связанные с удобством повторного использования и разработки. Поиск баланса этих сил, исходя из потребностей приложения, — непростая задача. Кроме того, баланс практически всегда постоянно смещается. То есть раз- биение, считающееся удачным сегодня, может оказаться неудачным через год. Как следствие, состав компонентов почти наверняка будет изменяться с течением времени и смещением фокуса проекта с удобства разработки к удобству повторного использования.
#### 3.10. Принцип ацикличности зависимости. Примеры.

=="Циклы в графе зависимостей компонентов недопустимы." - Роберт Мартин==

Бывало ли у вас так, что вы целый день проработали, заставили что-то заработать, а на следующее утро, придя на работу, обнаружили, что опять ничего не работает? Почему это произошло? Потому что кто-то задержался на работе дольше вас и изменил что-то, от чего зависит ваш код! Я называю это «синдромом следующего утра».

«Синдром следующего утра» возникает, когда одни и те же файлы с исходным кодом правят сразу несколько разработчиков.

За последние десятилетия было выработано два решения этой проблемы, и оба пришли из телекоммуникационной отрасли. Первое: **«еженедельные сборки»**. И второе: **соблюдение принципа ацикличности зависимостей** (Acyclic Dependencies Principle; ADP).

1. **Еженедельные сборки**

Еженедельные сборки часто используются в проектах среднего размера . Это решение действует так: все разработчики работают независимо первые четыре дня в неделе . Они изменяют собственные копии кода и не заботят- ся об интеграции результатов своего труда в коллективную основу . Затем, в пятницу, они объединяют свои изменения и пытаются собрать систему.

Этот подход имеет замечательное преимущество, позволяя разработчикам работать в изоляции четыре дня из пяти. Недостаток, конечно же, — боль- шие трудозатраты на интеграцию в пятницу.

2. **Устранение циклических зависимостей**

Решение этой проблемы заключается в разделении проекта на к*омпоненты, которые могут выпускаться независимо*. Компоненты становятся единицами работы, ответственность за которые можно возложить на одного разработчика или на небольшую группу. Когда разработчики добиваются работоспособности компонента, они выпускают *новую версию* для использования другими разработчиками. Они присваивают этой версии номер и помещают в *каталог*, доступный другим разработчикам. Затем продолжают разработку компонента, изменяя свои *локальные копии*. А все остальные используют *выпущенную версию*.

В результате ни одна команда не отдается на милость другим. Изменения в одном компоненте не оказывают немедленного влияния на другие команды. Каждая команда сама решает, когда начать адаптацию своего компонента для использования новой версии другого компонента. Кроме того, *интеграция происходит небольшими шагами*. Нет единого момента времени, когда все разработчики должны собраться вместе и интегрировать все, что они создали.

Этот очень простой и рациональный процесс получил широкое распространение. Однако чтобы добиться успеха, вы должны управлять структурой зависимостей компонентов. В ней не должно быть *циклических зависимостей*. Если в структуре зависимостей появятся циклы, *«синдрома следующего утра»* не избежать.

Взгляните на диаграмму компонентов на рис. Она демонстрирует типичную структуру компонентов, собранных в приложение. Обратите внимание, что структура имеет вид ориентированного (направленного) графа. Компоненты играют роль узлов, а зависимости между ними — ориентированных ребер.

![[Снимок экрана 2024-01-19 в 01.54.35.png]]

Обратите внимание на одну важную особенность: *с какого бы компонента вы ни начали, вы не сможете пройти по связям-зависимостям и вернуться обратно в этот же компонент*. Эта структура не имеет циклов. Это ациклический ориентированный граф.

Теперь представьте, что произойдет, когда одна из команд выпустит новую версию компонента *Presenters*. Определить, кого затронет этот факт, нетрудно, нужно лишь проследовать по стрелкам входящих зависимостей. То есть затронуты будут компоненты *View* и *Main*.

3. **Влияние циклов в графе зависимостей компонентов**

Предположим, что появление новых требований вынудило нас изменить один из классов в компоненте *Entities* так, что он стал использовать класс из компонента *Authorizer* . Например, допустим, что класс *User* из *Entities* стал использовать класс *Permissions* из *Authorizer* . В результате образовалась циклическая зависимость.

![[Снимок экрана 2024-01-19 в 01.57.54 1.png]]

Этот цикл немедленно приводит к появлению проблем. Например, разработчики, развивающие компонент *Database*, знают, что для выпуска новой версии они должны проверить совместимость с компонентом *Entities*. Но из-за образовавшегося цикла компонент *Database* теперь также должен быть совместим с *Authorizer*. Но *Authorizer* зависит от *Interactors* . Все это усложняет выпуск новой версии *Database*. *Entities*, *Authorizer* и *Interactors* фактически превращаются в один большой компонент — это означает, что всех разработчиков, развивающих эти компоненты, будет преследовать «синдром следующего утра».

Но список проблем этим не исчерпывается. Подумайте, что произойдет, когда нам потребуется протестировать компонент *Entities* . К нашему глубокому огорчению обнаружится, что мы должны собрать и интегрировать его с *Authorizer* и *Interactors*. Такая степень зависимости компонентов вызывает беспокойство, если она вообще допустима.

4. Разрыв цикла

Образовавшуюся циклическую зависимость всегда можно разорвать и привести граф зависимостей к форме ациклического ориентированного графа (DAG). Для этого используются два основных механизма:
* Применить принцип инверсии зависимостей (Dependency Inversion Principle; DIP). В этом случае, как показано на рис, можно было бы создать интерфейс, определяющий методы, необходимые классу *User*, затем поместить этот интерфейс в *Entities* и унаследовать его в *Authorizer*. Это обратило бы зависимость между *Entities* и *Authorizer* и разорвало цикл.

![[Снимок экрана 2024-01-19 в 02.02.28.png]]

* Создать новый компонент, от которого зависят *Entities* и *Authorizer*. Поместить в новый компонент класс(ы), от которых они оба зависят.

![[Снимок экрана 2024-01-19 в 02.06.38.png]]

=="Проблемы, что мы обсудили к данному моменту, ведут к однозначному заключению: *структура компонентов не может проектироваться сверху вниз*. К этому выводу приходят не сразу, как только начинают проектировать систему, но это неизбежно случается с ростом и изменением системы. Фактически диаграммы зависимостей компонентов слабо отражают функции приложения. В большей степени они являются отражением удобства сборки и сопровождения приложения. В этом главная причина, почему они не проектируются в начале разработки проекта ." - Роберт Мартин==
#### 3.11. Принцип устойчивых зависимостей. Примеры.

=="Зависимости должны быть направлены в сторону устойчивости." - Роберт Мартин==

Следуя **принципу согласованного изменения** (CCP), мы создаем компоненты, чувствительные к одним изменениям и невосприимчивые к другим. Некоторые из компонентов *изначально проектируются как изменчивые*. То есть мы ожидаем, что они будут изменяться. *Компоненты, с большим трудом поддающиеся изменению, не должны зависеть от любых изменчивых компонентов*. Иначе изменчивый компонент тоже трудно будет изменять.

*Устойчивость* связана с количеством работы, которую требуется проделать, чтобы изменить со- стояние. Есть один верный способ сделать программный компонент сложным для изменения — создать много других компонентов, зависящих от него. Компонент с множеством входящих зависимостей очень *устойчив*, потому что согласование изменений со всеми зависящими компонентами требует значительных усилий.

На рис представлена диаграмма с *устойчивым* компонентом X. От него зависят три других компонента, то есть имеется три веские причины не изменять его. Мы говорим, что X *несет ответственность* за эти три компонента. Сам компонент X, напротив, ни от чего не зависит, то есть на него не оказывается никаких внешних воздействий, которые могли бы привести к изменению . Мы говорим, что он *независим*.

![[Снимок экрана 2024-01-19 в 02.13.42.png]]

На рис снизу же - изображен очень *неустойчивый* компонент Y. От него не зависит никакой другой компонент, поэтому мы говорим, что он лишен ответственности.

**Метрики устойчивости:**
Как оценить *устойчивость* компонента? Один из способов — подсчитать количество *входящих* и *исходящих* зависимостей этого компонента. Эти числа позволят вычислить меру его устойчивости.
- Fan-in (число входов): количество входящих зависимостей . Эта метрика определяет количество классов вне данного компонента, которые зависят от классов внутри компонента.
- Fan-out (число выходов): количество исходящих зависимостей . Эта ме- трика определяет количество классов внутри данного компонента, за- висящих от классов за его пределами.
- I: неустойчивость: I = Fan-out ÷ (Fan-in + Fan-out) . Значение этой метрики изменяется в диапазоне 0-1 . I = 0 соответствует *максимальной устойчивости* компонента, I = 1 — *максимальной неустойчивости*.

*Не все компоненты должны быть устойчивыми*. Если все компоненты в системе будут иметь максимальную устойчивость, такую систему невозможно будет изменить. Это нежелательная ситуация. В действительности структура компонентов должна проектироваться так, чтобы в ней имелись и устойчивые, и неустойчивые компоненты. Диаграмма на рис. демонстрирует идеальную организацию системы с тремя компонентами.

![[Снимок экрана 2024-01-19 в 02.17.49.png]]

Изменяемые компоненты находятся вверху и зависят от устойчивого компонента внизу.

Диаграмма на рис. ниже же - демонстрирует нарушение принципа SDP.

![[Снимок экрана 2024-01-19 в 02.18.50.png]]

Компонент *Flexible* специально проектировался так, чтобы его было легко изменять. Предполагалось, что он будет *неустойчивым*. Но кто-то из разработчиков, работающих над компонентом *Stable*, создал зависимость от компонента *Flexible*. Это явное нарушение принципа SDP, потому что метрика I компонента *Stable* намного меньше метрики I компонента *Flexible*. Как результат, создание такой зависимости усложнило возможное изменение компонента *Flexible* . Теперь любые изменения в компоненте *Flexible* придется согласовывать с компонентом *Stable* и всеми компонентами, зависящими от него.

Исправить ситуацию можно, применив **принцип инверсии зависимостей** (DIP) . Для этого определим интерфейс US и поместим его в компонент с именем *UServer*. Этот интерфейс должен объявлять все методы, используемые классом U . Затем реализуем этот интерфейс в классе C, как показано на рис . 14 .11 . Это разорвет зависимость *Stable* от *Flexible* и вынудит оба компонента зависеть от *UServer*. *UServer* очень устойчив (I = 0), а *Flexible* сохранит желаемую неустойчивость (I = 1) . Теперь все зависимости про- стираются в сторону уменьшения I.

![[Снимок экрана 2024-01-19 в 02.20.57.png]]

**Заключение**: нужно использовать ссылки на компоненты, которые будут редко меняться и избегать **зависимостей** от изменчивых компонентов. Это добавит гибкость в разработке, так как всегда нужны компоненты, которые можно легко изменять.
#### 3.12. Принцип устойчивых абстракций. Примеры.

=="*Устойчивость* компонента пропорциональна его *абстрактности*." - Роберт Мартин==

1. Куда поместить высокоуровневые правила?

Некоторые части программных систем должны меняться очень редко. Эти части представляют *высокоуровневые* архитектурные и другие важные решения. Никто не желает, чтобы такие решения были *изменчивыми*. Поэтому программное обеспечение, инкапсулирующее высокоуровневые правила, должно находиться в *устойчивых* компонентах (I = 0). *Неустойчивые* (I = 1) должны содержать только изменчивый код — код, который можно было бы легко и быстро изменить.

Но если высокоуровневые правила поместить в *устойчивые* компоненты, это усложнит изменение исходного кода, реализующего их. Это может сделать всю архитектуру негибкой. Как компонент с максимальной устойчивостью (I = 0) сделать гибким настолько, чтобы он сохранял устойчивость при изменениях? Ответ заключается в соблюдении принципа открытости/закрытости (OCP). Этот принцип говорит, что можно и нужно создавать классы, достаточно гибкие, чтобы их можно было наследовать (расширять) без изменения. Какие классы соответствуют этому принципу? **Абстрактные**.

2. Введение в принцип устойчивости абстракций

**Принцип устойчивости абстракций** (Stable Abstractions Principle; SAP) устанавливает связь между *устойчивостью* и *абстрактностью*. С одной стороны, он говорит, что *устойчивый* компонент также должен быть *абстрактным*, чтобы его устойчивость не препятствовала расширению, с другой — он говорит, что *неустойчивый* компонент должен быть *конкретным*, потому что неустойчивость позволяет легко изменять его код. То есть *стабильный* компонент должен состоять из *интерфейсов* и *абстрактных классов*, чтобы его легко было расширять.

Принципы **устойчивости абстракций** (SAP) и **устойчивых зависимостей** (SDP) вместе соответствуют **принципу инверсии зависимостей** (DIP) для компонентов. Это верно, потому что принцип SDP требует, чтобы зависимости были направлены в сторону устойчивости, а принцип SAP утверждает, что устойчивость подразумевает абстрактность. То есть зависимости должны быть направлены в сторону абстрактности.

Однако принцип DIP сформулирован для классов, и в случае с классами нет никаких полутонов. Класс либо *абстрактный*, либо нет. Принципы SDP и SAP действуют в отношении компонентов и допускают ситуацию, когда компонент частично абстрактный или частично устойчивый.

3. Мера абстрактности

*Мерой абстрактности* компонента служит метрика A . Ее значение определяется простым отношением количества интерфейсов и абстрактных классов к общему числу классов в компоненте.
- Nc: число классов в компоненте .  
- Na: число абстрактных классов и интерфейсов в компоненте .  A: абстрактность . 
- A = Na ÷ Nc .

Значение метрики A изменяется в диапазоне от 0 до 1 . 0 означает полное отсутствие абстрактных классов в компоненте, а 1 означает, что компонент не содержит ничего, кроме абстрактных классов.

4. Главная последовательность

Теперь мы можем определить зависимость между *устойчивостью* (I) и *абстрактностью* (A). Если нанести на график «хорошие» компоненты обоих видов, обнаружится, что *максимально устойчивые и абстрактные находятся слева вверху*, в точке с координатами (0, 1), *а максимально неустойчивые и конкретные — справа внизу*, в точке (1, 0).

![[Снимок экрана 2024-01-19 в 02.30.30.png]]

Так как нельзя потребовать, чтобы все компоненты находились в двух точках (0, 1) или (1, 0), мы должны предположить, что на графике A/I имеется некоторое множество точек, определяющих оптимальные позиции для компонентов. Вывести это множество можно, определив области, где компоненты не должны находиться, — иными словами, определив зоны исключения.

![[Снимок экрана 2024-01-19 в 02.31.26.png]]

5. Зона боли

Рассмотрим компонент в точке (0, 0). Это очень устойчивый и конкретный компонент . Такие компоненты нежелательны, потому что слишком жесткие. Их нельзя расширить, потому что они неабстрактные, и очень трудно изменить из-за большой устойчивости. Поэтому правильно спроектированные компоненты обычно не должны находиться рядом с точкой (0, 0). Область вокруг точки (0, 0) — это зона исключения, которую называют *зоной боли*.

6. Зона бесполезности

Рассмотрим компонент рядом с точкой (1, 1). Такие компоненты также нежелательны, потому что они максимально абстрактны и не имеют входящих зависимостей. Они бесполезны . Поэтому данная область так и называется: зона бесполезности.

7. Как не попасть в зоны исключения

Компонент, располагающийся на главной последовательности, не «слишком абстрактный» для своей устойчивости и не «слишком неустойчив» для своей абстрактности. Он не бесполезен и не доставляет особенной боли. От него зависят другие компоненты в меру его абстрактности, и сам он зависит от других в меру конкретности.

**Заключение**: метрики управления зависимостями, описанные в этой главе, помогают получить количественную оценку соответствия структуры зависимостей и абстракции дизайна тому, что я называю «хорошим» дизайном. Как показывает опыт, есть хорошие зависимости, есть плохие. Данная оценка отражает этот опыт.
## 4. Архитектурные паттерны
---
#### 4.1. Паттерны сохраняемости. DAO и Unit of work. Пример реализации.

1. DAO

**Data Access Object (DAO) используется для абстрагирования и инкапсулирования доступа к источнику данных (БД). DAO управляет соединением с источником данных для получения и записи данных.**

На рисунке показана диаграмма классов, представляющая взаимоотношения в паттерне DAO.

![[Снимок экрана 2024-01-19 в 02.57.59.png]]

**BusinessObject** представляет клиента данных. Это объект, который нуждается в доступе к источнику данных для получения и сохранения данных. BusinessObject может быть реализован как сессионный компонент, компонент управления данными или другой Java-объект, сервлет или вспомогательный компонент.

**DataAccessObject** является первичным объектом данного паттерна. DataAccessObject абстрагирует используемую реализацию доступа к данным для BusinessObject, обеспечивая прозрачный доступ к источнику данных. BusinessObject передает также ответственность за выполнение операций загрузки и сохранения данных объекту DataAccessObject.

**TransferObject** - используемый для передачи данных. DataAccessObject может использовать Transfer Object для возврата данных клиенту. DataAccessObject может также принимать данные от клиента в объекте Transfer Object для их обновления в источнике данных.

**Пример реализации:**

```csharp 
// Student 
public class Student {
   private String name;
   private int rollNo;

   Student(String name, int rollNo){
      this.name = name;
      this.rollNo = rollNo;
   }

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }

   public int getRollNo() {
      return rollNo;
   }

   public void setRollNo(int rollNo) {
      this.rollNo = rollNo;
   }
}
```

```csharp
// DAO
public class StudentDao {
   // Лист вместо БД
   List<Student> students;

   public StudentDao(){
      students = new ArrayList<Student>();
      Student student1 = new Student("Robert",0);
      Student student2 = new Student("John",1);
      students.add(student1);
      students.add(student2);		
   }

   public void deleteStudent(Student student) {
      students.remove(student.getRollNo());
   }

   public List<Student> getAllStudents() {
      return students;
   }

   public Student getStudent(int rollNo) {
      return students.get(rollNo);
   }

   public void updateStudent(Student student) {
      students[student.getRollNo()] = student.getName();
   }
}
```

```csharp
// Используем
StudentDao studentDao = new StudentDao();

for (var student in studentDao.getAllStudents()) {
	  Console.Write("Student: [RollNo : " + student.getRollNo() + ", Name : " + student.getName() + " ]");
      }

      Student student = studentDao.getAllStudents().FirstOrDefault();
      student.setName("Michael");
      studentDao.updateStudent(student);

      studentDao.getStudent(0);
      Console.Write("Student: [RollNo : " + student.getRollNo() + ", Name : " + student.getName() + " ]");
```

2. Unit of work

В приложениях часто юзается шаблон Repository для инкапсуляции логики работы с БД. Часто приходится оперировать множеством сущностей и моделей, для управления которыми создается также большое количество репозиториев. Паттерн Unit of Work помогает упростить работу с различными репозиториями и дает уверенность, что все репозитории будут использовать один и тот же DbContext.

![[Снимок экрана 2024-01-19 в 03.27.29.png]]

**Пример реализации:** 

Допустим, у нас есть следующая пара моделей:
```csharp
public class Book {
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}

public class Order {
    public int Id { get; set; }
    public string Number { get; set; }
    public int BookId { get; set; }
    public Book Book { get; set; }
}

```

И также имеется следующий контекст данных:
```csharp
public class OrderContext : DbContext {
    public DbSet<Book> Books { get; set; }
    public DbSet<Order> Orders { get; set; }
}
```

Если мы будем использовать паттерн Репозиторий для работы с базой данных, то мы можем определить интерфейс репозитория и создать две его отдельных реализации: `BookRepository` и `OrderRepository` которые реализуют интерфейс:
```csharp
interface IRepository<T> where T : class {
    IEnumerable<T> GetAll();
    T Get(int id);
    void Create(T item);
    void Update(T item);
    void Delete(int id);
}
```

Тогда определим класс `UnitOfWork`:
```csharp
public class UnitOfWork : IDisposable {
    private OrderContext db = new OrderContext(); // DBContext
    private BookRepository bookRepository;
    private OrderRepository orderRepository;

    public BookRepository Books {
        get
        {
            if (bookRepository == null)
                bookRepository = new BookRepository(db);
            return bookRepository;
        }
    }

    public OrderRepository Orders {
        get
        {
            if (orderRepository == null)
                orderRepository = new OrderRepository(db);
            return orderRepository;
        }
    }
    
    public void Save() {
        db.SaveChanges();
    }

    private bool disposed = false;

    public virtual void Dispose(bool disposing) {
        if (!this.disposed)
        {
            if (disposing)
            {
                db.Dispose();
            }
            this.disposed = true;
        }
    }
    
    public void Dispose() {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}
```
#### 4.2. Паттерны сохраняемости. DataSet, Repository и Query Object. Пример реализации.

2. Repository

![[Снимок экрана 2024-01-19 в 06.55.19.png]]
![[Снимок экрана 2024-01-19 в 06.56.07.png]]
![[Снимок экрана 2024-01-19 в 06.56.47.png]]
![[Снимок экрана 2024-01-19 в 06.57.36.png]]
![[Снимок экрана 2024-01-19 в 06.58.55.png]]

**Пример реализации:**
```csharp
public interface ICustomerRepository 
{        
	IEnumerable GetCustomers();        
	Customer GetCustomerByID(int customerId);        
	void InsertCustomer(Customer customer);        
	void DeleteCustomer(int customerId);        
	void UpdateCustomer(Customer customer);        
	void Save();    
}
```
```csharp
public class CustomerRepository:ICustomerRepository    
 2 {        
 3     private ApplicationContext context;        
 4  
 5     public CustomerRepository(ApplicationContext context)        
 6     {            
 7         this.context = context;        
 8     }        
 9     
10     public IEnumerable<Customer> GetCustomers()        
11     {            
12         return context.Customers.ToList();        
13     }        
14     public Customer GetCustomerByID(int customerId)        
15     {
16         return context.Customers.Find(customerId);
17     }
18     
19     public void InsertCustomer(Customer customer)
20     {            
21         context.Customers.Add(customer);      
22     }        
23     
24     public void DeleteCustomer(int customerId)        
25     {            
26         Customer customer = context.Customers.Find(customerId);                    
27         context.Customers.Remove(customer);        
28     }        
29     
30     public void UpdateCustomer(Customer customer)        
31     {            
32         context.Entry(customer).State = EntityState.Modified;        
33     }        
34     
35     public void Save()        
36     {            
37         context.SaveChanges();        
38     }
39     
40 }
```
```csharp
public class CustomerController : Controller
 2 {
 3   private UnitOfWork unitOfWork = new UnitOfWork();
 4 
 5   // GET: /Customer/
 6   public ViewResult Index()
 7   {
 8      var Customers = unitOfWork.CustomerRepository.Get();
 9      return View(Customers.ToList());
10   }
11 
12   // GET: /Customer/Details/5
13   public ViewResult Details(int id)
14   {
15      Customer Customer = unitOfWork.CustomerRepository.GetByID(id);
16      return View(Customer);
17   }
18 
19   // GET: /Customer/Create
20   public ActionResult Create()
21   {
22      return View();
23   }
24 
25   [HttpPost]
26   [ValidateAntiForgeryToken]
27   public ActionResult Create(Customer Customer)
28   {
29      try
30      {
31         if (ModelState.IsValid)
32         {
33            unitOfWork.CustomerRepository.Insert(Customer);
34            unitOfWork.Save();
35            return RedirectToAction("Index");
36         }
37      }
38      catch (DataException)
39      {
40         ModelState.AddModelError("", "Unable to save changes.");
41      }
42      return View(Customer);
43   }
44 
45   public ActionResult Edit(int id)
46   {
47      Customer Customer = unitOfWork.CustomerRepository.GetByID(id);     
48      return View(Customer);
49   }
50 
51   [HttpPost]
52   [ValidateAntiForgeryToken]
53   public ActionResult Edit(       
54      Customer Customer)
55   {
56      try
57      {
58         if (ModelState.IsValid)
59         {
60            unitOfWork.CustomerRepository.Update(Customer);
61            unitOfWork.Save();
62            return RedirectToAction("Index");
63         }
64      }
65      catch (DataException)
66      {
67         ModelState.AddModelError("", "Unable to save changes.");
68      }
69      return View(Customer);
70   }
71 
72   // GET: /Customer/Delete/5
73   public ActionResult Delete(int id)
74   {
75      Customer Customer = unitOfWork.CustomerRepository.GetByID(id);
76      return View(Customer);
77   }
78 
79   // POST: /Customer/Delete/5
80   [HttpPost, ActionName("Delete")]
81   [ValidateAntiForgeryToken]
82   public ActionResult DeleteConfirmed(int id)
83   {
84      Customer Customer = unitOfWork.CustomerRepository.GetByID(id);
85      unitOfWork.CustomerRepository.Delete(id);
86      unitOfWork.Save();
87      return RedirectToAction("Index");
88   }
89 
90   protected override void Dispose(bool disposing)
91   {
92      unitOfWork.Dispose();
93      base.Dispose(disposing);
94   }
95 }
```

3. Query object

![[Снимок экрана 2024-01-19 в 07.03.31.png]]
![[Снимок экрана 2024-01-19 в 07.04.20.png]]
![[Снимок экрана 2024-01-19 в 07.04.51.png]]

**Пример реализации:**
```csharp
public interface IProductRepository
{
	void Insert(Product product);
	void Delete(Product product);
	IEnumerable<Product> GetById(Guid id);
	IEnumerable<Product> GetAllActive();
	IEnumerable<Product> FindByName(string name);
	IEnumerable<Product> FindBySku(string name);
	IEnumerable<Product> Find(string keyword, int limit, int page);
	IEnumerable<Product> GetRelated(Guid id);
}

public ViewResult ProductDetails(Guid productId)
{
	var product = _productRepository.GetById(productId);
	var relatedProducts = _productRepository.GetRelated(productId);
	
	var model = new ProductDetailsModel
	{
		Id = product.Id,
		Name = product.Name,
		Price = product.Price,
		PriceFormatted = product.Price.ToString("C"),
		RecommendedProducts = (from x in relatedProducts select new ProductDetailModel.RecommendedProducts {
				ProductId = x.RecommendedProductId,
				Name = x.Name,
				Price = x.Price,
				PriceFormatted = x.Price.ToString("C")
			})
	};

	return View(model);
}

public class ProductDetailsQuery
{
	public Guid ProductID { get; private set; }
	
	public ProductDetailQuery(Guid productId)
	{
		ProductId = productId
	}
}

public class ProductDetailQueryHandler
{
	private DbContext _db;
	
	public ProductDetailQueryHandler(DbContext db)
	{
		_db = db;
	}
	
	public ProductDetailModel Handle(ProductDetailQuery query)
	{
		var product = (from p in _db.Products where p.ProductId == query.ProductId).SingleOrDefault();
		if (product == null) {
			throw new InvalidOperationException("Product does not exist.");
		}
		
		var relatedProducts = (from p in _db.RecommendedProducts where p.PrimaryProductId == query.ProductId);
		
		return new ProductDetailsModel
		{
			Id = product.Id,
			Name = product.Name,
			Price = product.Price,
			PriceFormatted = product.Price.ToString("C"),
			RecommendedProducts = (from x in relatedProducts select new ProductDetailModel.RecommendedProducts {
				ProductId = x.RecommendedProductId,
				Name = x.Name,
				Price = x.Price,
				PriceFormatted = x.Price.ToString("C")
			})
		};
	}
}

public ViewResult ProductDetails(ProductDetailQuery query)
{
	var model = _queryHandler(query);
	return View(model);
}
```

#### 4.3. Паттерны сохраняемости. Active Record. Пример реализации.

![[Снимок экрана 2024-01-19 в 04.35.40.png]]
![[Снимок экрана 2024-01-19 в 04.36.27.png]]
![[Снимок экрана 2024-01-19 в 04.38.48.png]]
![[Снимок экрана 2024-01-19 в 04.39.29.png]]

**Пример реализации:**
```csharp
// Модель
public class Student : DbContext
{ 
	public DbSet<Student> Students { get; set; }
	public int ID { get; set; } 
	public string LastName { get; set; } 
	public string FirstMidName { get; set; } 
	public DateTime EnrollmentDate { get; set; } 
	public virtual ICollection<Enrollment> Enrollments { get; set; }

	public void addStdnt() {
	   try {
	   Students.Add(this);
       Students.SaveChanges();
       }
       catch (Exception ex) {
       Console.WriteLine(ex.Message);
       }
	}

	public void removeStdnt() {...}
}
```

Или:
```csharp
public class Customer
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public bool IsPremiumMember { get; set; }
        public Customer(int id, string name, bool isPremiumMember)
        {
            ID = id;
            Name = name;
            IsPremiumMember = isPremiumMember;
        }

        public static Customer GetByID(int id)
        {
            using(SqlConnection connection = new SqlConnection(CONNECTION_STRING))
            {
                connection.Open();
                using(SqlCommand command = connection.CreateCommand())
                {
                    command.CommandType = CommandType.Text;
                    command.CommandText = "SELECT TOP 1 * FROM [Customer] WHERE [ID] = @ID";
                    command.Parameters.AddWithValue("@ID", id);
                    SqlDataReader reader = command.ExecuteReader();
                    // If the query returned a row, create the Customer object and return it.
                    if(reader.HasRows)
                    {
                        reader.Read();
                        string name = (string) reader["Name"];
                        bool isPremiumMember = (bool) reader["IsPremiumMember"];
                        return new Customer(id, name, isPremiumMember);
                    }
                }
            }
            return null;
        }
        public void Save()
        {
	        ///
        }
        public void Delete()
        {
            using(SqlConnection connection = new SqlConnection(CONNECTION_STRING))
            {
                connection.Open();
                using(SqlCommand command = connection.CreateCommand())
                {
                    command.CommandType = CommandType.Text;
                    command.CommandText = "DELETE FROM [Customer] WHERE [ID] = @ID";
                    command.Parameters.AddWithValue("@ID", ID);
                    command.ExecuteNonQuery();
                }
            }
        }
    }
```
#### 4.4. Паттерны сохраняемости. Ленивая загрузка. Пример реализации.

![[Снимок экрана 2024-01-19 в 05.07.39.png]]
![[Снимок экрана 2024-01-19 в 05.08.10.png]]
![[Снимок экрана 2024-01-19 в 05.08.42.png]]
![[Снимок экрана 2024-01-19 в 05.10.01.png]]
![[Снимок экрана 2024-01-19 в 05.11.17.png]]
![[Снимок экрана 2024-01-19 в 05.12.22.png]]
![[Снимок экрана 2024-01-19 в 05.12.49.png]]
![[Снимок экрана 2024-01-19 в 05.13.14.png]]
![[Снимок экрана 2024-01-19 в 05.13.37.png]]
![[Снимок экрана 2024-01-19 в 05.14.15.png]]
![[Снимок экрана 2024-01-19 в 05.14.47.png]]
![[Снимок экрана 2024-01-19 в 05.15.12.png]]
![[Снимок экрана 2024-01-19 в 05.15.37.png]]
#### 4.5. Паттерны сохраняемости. TPC, TPH, TPT. Пример реализации.

Всего в `Entity Framework` есть всего 3 подхода к реализации наследования : 

1. **TPH** (Table Per Hierarchy - Таблица на одну иерархию классов)

При использовании данного подхода - для одной иерархии классов используется одна таблица. 

Данные базовых и производных классов сохраняются в одну таблицу, а для их отличия создается специальный столбец.

**Пример реализации:**
Итак у нас есть базовая мини-иерархия двух классов:
```csharp
public class Phone
{
	public int Id { get; set; }
    public string Name { get; set; }
    public string Company { get; set; }
    public int Price { get; set; }
}

public class Smartphone : Phone
{
    public string OS { get; set; }
}

class MobileContext : DbContext
{
    public MobileContext() : base("DefaultConnection")
    { }
    public DbSet<Phone> Phones { get; set; }
    public DbSet<Smartphone> Smarts { get; set; }
}
```

При этом БД выглядит так:
![[Снимок экрана 2024-01-19 в 04.59.21.png]]

Работа в программе:
```csharp
using(MobileContext db = new MobileContext())
{
    db.Phones.Add(new Phone {Name = "Samsung Galaxy S5", Company = "Samsung", Price = 14000 });
    db.Phones.Add(new Phone {Name = "Nokia Lumia 630", Company = "Nokia", Price = 8000 });

    Smartphone s1 = new Smartphone { Name = "iPhone 6", Company = "Apple", Price = 32000, OS = "iOS" };
    db.Smarts.Add(s1);
    db.SaveChanges();

    foreach (Phone p in db.Phones)
        Console.WriteLine("{0} ({1}) - {2}", p.Name, p.Company, p.Price);
    Console.WriteLine();
    foreach (Smartphone p in db.Smarts)
        Console.WriteLine("{0} ({1}, {2}) - {3}", p.Name, p.Company, p.Price, p.OS);
}
```

**Обратим внимание на одну деталь :** при выводе данных из `Phones` также будет идти вывод экземпляра `Smartphone` вместе с остальными экземплярами ,поскольку здесь `SmartPhone` и есть объектом `Phone`.

2. **TPT** (Table Per Type - Таблица на тип) 

Данный подход предполагает сохранение в общей таблице только тех свойств, которые общие для всех классом-наследников, то есть которые определены в базовом классе.

А те свойства, которые относятся только к производному классу, сохраняются в отдельной таблице.

**Пример реализации:**
Чтобы применить подход, возьмем из предыдущего примера систему классов и добавим к классу `Smartphone` атрибут `[Table]`:
```csharp
public class Phone
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Company { get; set; }
    public int Price { get; set; }
}
[Table("Smartphones")]
public class Smartphone : Phone
{
    public string OS { get; set; }
}
class MobileContext : DbContext
{
    public MobileContext() : base("DefaultConnection")
    { }
    public DbSet<Phone> Phones { get; set; }
    public DbSet<Smartphone> Smarts { get; set; }
}
```

Всё остальное остается также, как и при подходе **TPH**. Но теперь база данных будет содержать следующие таблицы:
![[Снимок экрана 2024-01-19 в 05.00.27.png]]

Таблица для смартфонов содержит только одно поле `OS`, а также ключ `Id` для связи с таблицей `Phones`.

Применение моделей будет аналогично подходу **TPH(пункт выше)**:
```csharp
using(MobileContext db = new MobileContext())
{
    db.Phones.Add(new Phone {Name = "Samsung Galaxy S5", Company = "Samsung", Price = 14000 });
    db.Phones.Add(new Phone {Name = "Nokia Lumia 630", Company = "Nokia", Price = 8000 });

    Smartphone s1 = new Smartphone { Name = "iPhone 6", Company = "Apple", Price = 32000, OS = "iOS" };
    db.Smarts.Add(s1);
    db.SaveChanges();

    foreach (Phone p in db.Phones)
        Console.WriteLine("{0} ({1}) - {2}", p.Name, p.Company, p.Price);
    Console.WriteLine();
    foreach (Smartphone p in db.Smarts)
        Console.WriteLine("{0} ({1}, {2}) - {3}", p.Name, p.Company, p.Price, p.OS);
}
```

3. **TPC** (Table Per Class(Concrete Type) 

Таблица на каждый отдельный тип/класс) - предполагает создание для каждой модели по отдельной таблицы. Столбцы в каждой таблице создаются по всем свойствам, в том числе и унаследованным.

**Пример реализации:**
Чтобы применить подход, изменим объявления моделей и контекст следующим образом:
```csharp
public class Phone
{
    [Key, DatabaseGenerated (DatabaseGeneratedOption.Identity)]
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Company { get; set; }
    public int Price { get; set; }
}

public class Smartphone : Phone
{
    public string OS { get; set; }
}

class MobileContext : DbContext
{
    public MobileContext() : base("DefaultConnection")
    { }
    public DbSet<Phone> Phones { get; set; }
    public DbSet<Smartphone> Smarts { get; set; }
    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Phone>()
        .Map(m =>
        {
            m.MapInheritedProperties();
            m.ToTable("Phones");
        });
        modelBuilder.Entity<Smartphone>().Map(m =>
        {
            m.MapInheritedProperties();
            m.ToTable("Smarts");
        });
    }
}
```

**Во-первых**, обратите внимание, что у класса `Phone` в качестве типа ключа используется не `int`, а `Guid`. Это поможет нам избежать некоторых проблем с ключами. Хотя также можно было бы использовать `int` с ручной установкой `Id` при создании объекта.

**Во-вторых**, при настройке сопоставления моделей и таблиц у каждой модели вызывается метод `MapInheritedProperties()`, который указывает `Entity Framework`-у, что в таблицу для данной модели надо включить также наследуемые свойства, а не только те, которые определены непосредственно в этой модели.

При генерации базы данных у нас будут созданы две таблицы с полным набором столбцов:
![[Снимок экрана 2024-01-19 в 05.02.56.png]]

Применение моделей:
```csharp
using(MobileContext db = new MobileContext())
{
    db.Phones.Add(new Phone {Name = "Samsung Galaxy S5", Company = "Samsung", Price = 14000 });
    db.Phones.Add(new Phone {Name = "Nokia Lumia 630", Company = "Nokia", Price = 8000 });

    Smartphone s1 = new Smartphone { Name = "iPhone 6", Company = "Apple", Price = 32000, OS = "iOS" };
    db.Smarts.Add(s1);
    db.SaveChanges();

    foreach (Phone p in db.Phones)
        Console.WriteLine("{0} ({1}) - {2}", p.Name, p.Company, p.Price);
    Console.WriteLine();
    foreach (Smartphone p in db.Smarts)
        Console.WriteLine("{0} ({1}, {2}) - {3}", p.Name, p.Company, p.Price, p.OS);
}
```

**Несмотря на то, что** объект `Smartphone` никак не связан с таблицей `Phones`, при извлечении данных он также будет находится в наборе `db.Phones`, потому что наследование все равно будет действовать.

Сравнение подходов:
1. **Скорость исполнения(работы)** - **TPH** -> _Таблица на одну иерархию_ классов в общем имеет лучшую скорость хотя бы **потому ,что** на не надо делать запросы `JOIN`поскольку все данные в одной таблице . Такое решение становиться даже **более очевидным** ,_когда у нас наследственная иерархия делается "шире" и "глубже"_.
2. **Гибкость** - **TPT** -> _Таблица на тип_ более гибкая потому,что решает проблему редактирования и обновлений колонок дочерней-таблицы при этом не изменяя родительскую таблицу.
3. **Эстетичность** - **TPT** -> это уже чисто субъективное мнение ,но как по-мне ,то _TPT_выглядит для мене более объектно-ориентированным подходом.
4. **Использование памяти** - **TPT** -> если у вас иерархия наследования имеет очень много различных типов , то использование _TPT_ позволит использовать данные ,которые имеют много незаполненных полей , **тем более** ,если структура баз данных решает проблему множества пустых полей ,то эта проблема вряд ли скажется на производительности работы запросов.
#### 4.6. Паттерны представления данных и обработки ввода. MVC. Пример реализации. 

![[Снимок экрана 2024-01-19 в 08.04.03.png]]
![[Снимок экрана 2024-01-19 в 08.04.27.png]]
![[Снимок экрана 2024-01-19 в 08.04.55.png]]
![[Снимок экрана 2024-01-19 в 08.05.52.png]]
![[Снимок экрана 2024-01-19 в 08.06.44.png]]

Пример реализации:
```csharp
// Model
public class Person 
{ 
	public int PersonId { get; set; } 
	
	[Required] 
	[MinLength(2)] 
	public string Name { get; set; } 
	
	[Phone] 
	public string PhoneNumber 
	{ get; set; } \
	
	[EmailAddress] 
	public string Email { get; set; } 
}

// Controller
public class PeopleController : Controller 
{ 
	private readonly AddressBookContext _context; 
	public PeopleController(AddressBookContext context) { _context = context; } 

	// GET: /people 
	public async Task Index() 
	{ 
		return View(await _context.People.ToListAsync()); 
	} 
	
	// GET: /people/details/5 
	public async Task Details(int id) 
	{ 
		var person = await _context.People.Find(id); 
		if (person == null) 
		{ 
			return NotFound(); 
		} 
		return View(person); 
	} 
}
```
```html
@model WebApplication.ViewModels.Person 

<h2>Wow!</h2> 
<address> 
	@Model.Name<br> 
	<abbr title="Phone">@Model.Phone</abbr> 
</address>
```
#### 4.7. Паттерны представления данных и обработки ввода. MVVM. Пример реализации.
#### 4.8. Паттерны распределенного взаимодействия. Remote Facade и Data Transfer Object. Пример реализации.

1. Remote Facade

![[Снимок экрана 2024-01-19 в 07.46.17.png]]
![[Снимок экрана 2024-01-19 в 07.46.46.png]]
![[Снимок экрана 2024-01-19 в 07.47.31.png]]
![[Снимок экрана 2024-01-19 в 07.48.12.png]]
![[Снимок экрана 2024-01-19 в 07.48.59.png]]

**Пример реализации:**
![[Снимок экрана 2024-01-19 в 07.50.36.png]]
![[Снимок экрана 2024-01-19 в 07.50.55.png]]
![[Снимок экрана 2024-01-19 в 07.51.14.png]]
![[Снимок экрана 2024-01-19 в 07.51.35.png]]
![[Снимок экрана 2024-01-19 в 07.52.01.png]]
![[Снимок экрана 2024-01-19 в 07.52.40.png]]

2. DTO

![[Снимок экрана 2024-01-19 в 07.54.28.png]]
![[Снимок экрана 2024-01-19 в 07.54.53.png]]
![[Снимок экрана 2024-01-19 в 07.55.43.png]]
![[Снимок экрана 2024-01-19 в 07.56.22.png]]
![[Снимок экрана 2024-01-19 в 07.57.34.png]]
![[Снимок экрана 2024-01-19 в 07.57.53.png]]

**Пример реализации:**
```csharp
namespace BookService.Models 
{ 
	public class BookDto 
	{ 
		public int Id { get; set; } 
		public string Title { get; set; } 
		public string AuthorName { get; set; } 
	} 
} 

namespace BookService.Models 
{ 
	public class BookDetailDto 
	{ 
		public int Id { get; set; } 
		public string Title { get; set; } 
		public int Year { get; set; } 
		public decimal Price { get; set; } 
		public string AuthorName { get; set; } 
		public string Genre { get; set; } 
	} 
}

// GET api/Books 
public IQueryable<BookDto> GetBooks() 
{ 
	var books = from b in db.Books select new BookDto() { Id = b.Id, Title = b.Title, AuthorName = b.Author.Name }; 
	return books; } 

// GET api/Books/5 
[ResponseType(typeof(BookDetailDto))] 
public async Task<IHttpActionResult> GetBook(int id) 
{ 
	var book = await db.Books.Include(b => b.Author).Select(b => new BookDetailDto() 
	{ 
		Id = b.Id, 
		Title = b.Title, 
		Year = b.Year, 
		Price = b.Price, 
		AuthorName = b.Author.Name, 
		Genre = b.Genre 
	}).SingleOrDefaultAsync(b => b.Id == id); 
	if (book == null) { return NotFound(); } 
	return Ok(book); 
}
```
#### 4.9. Паттерны распределенного взаимодействия. CQRS. Пример реализации.
#### 4.10. Паттерны распределенного взаимодействия. Event Sourcing. Пример реализации.
#### 4.11. Базовые архитектурные паттерны. Gateway и Mapper. Пример реализации.

1. Gateway 

![[Снимок экрана 2024-01-19 в 07.40.45.png]]
![[Снимок экрана 2024-01-19 в 07.41.40.png]]
![[Снимок экрана 2024-01-19 в 07.42.06.png]]

2. Mapper

![[Снимок экрана 2024-01-19 в 07.43.30.png]]
![[Снимок экрана 2024-01-19 в 07.43.56.png]]

**Пример реализации:**
```csharp
// Модель
    public class Customer
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public bool IsPremiumMember { get; set; }
        public Customer(int id, string name, bool isPremiumMember)
        {
            ID = id;
            Name = name;
            IsPremiumMember = isPremiumMember;
        }
    }
```

```csharp
// Маппер
public class CustomerDataMapper
    {
        public static Customer GetByID(int id)
        {
            using(SqlConnection connection = new SqlConnection(CONNECTION_STRING))
            {
                connection.Open();
                using(SqlCommand command = connection.CreateCommand())
                {
                    command.CommandType = CommandType.Text;
                    command.CommandText = "SELECT TOP 1 * FROM [Customer] WHERE [ID] = @ID";
                    command.Parameters.AddWithValue("@ID", id);
                    SqlDataReader reader = command.ExecuteReader();

                    if(reader.HasRows)
                    {
                        reader.Read();
                        string name = (string)reader["Name"];
                        bool isPremiumMember = (bool)reader["IsPremiumMember"];
                        return new Customer(id, name, isPremiumMember);
                    }
                }
            }
            return ERR_NOT_FOUND;
        }
 
        public void Save(Customer customer)
        {
		    //
        }
        
        public void Delete(Customer customer)
        {
            using(SqlConnection connection = new SqlConnection(CONNECTION_STRING))
            {
                connection.Open();
                using(SqlCommand command = connection.CreateCommand())
                {
                    command.CommandType = CommandType.Text;
                    command.CommandText = "DELETE FROM [Customer] WHERE [ID] = @ID";
                    command.Parameters.AddWithValue("@ID", customer.ID);
                    command.ExecuteNonQuery();
                }
            }
        }
    }
```
#### 4.12. Базовые архитектурные паттерны. Value Object и Special Case. Пример реализации.

1. Value Object

![[Снимок экрана 2024-01-19 в 07.10.14.png]]
![[Снимок экрана 2024-01-19 в 07.10.40.png]]
![[Снимок экрана 2024-01-19 в 07.11.46.png]]
![[Снимок экрана 2024-01-19 в 07.12.23.png]]
![[Снимок экрана 2024-01-19 в 07.12.59.png]]

**Пример реализации:**
```csharp
public abstract class ValueObject 
{ 
	protected static bool EqualOperator(ValueObject left, ValueObject right) 
	{ 
		if (ReferenceEquals(left, null) ^ ReferenceEquals(right, null)) 
		{ 
			return false; 
		} 
		return ReferenceEquals(left, right) || left.Equals(right); 
	} 
	protected static bool NotEqualOperator(ValueObject left, ValueObject right)
	{ 
		return !(EqualOperator(left, right)); 
	} 
	protected abstract IEnumerable<object> GetEqualityComponents(); 
	public override bool Equals(object obj) 
	{ 
		if (obj == null || obj.GetType() != GetType()) 
		{ 
			return false; 
		} 
		var other = (ValueObject)obj; 
		return this.GetEqualityComponents().SequenceEqual(other.GetEqualityComponents()); 
	} 
	public override int GetHashCode() 
	{ 
		return GetEqualityComponents() .Select(x => x != null ? x.GetHashCode() : 0) .Aggregate((x, y) => x ^ y); 
	} 
}

public class Address : ValueObject 
{ 
	public String Street { get; private set; } 
	public String City { get; private set; } 
	public String State { get; private set; } 
	public String Country { get; private set; } 
	public String ZipCode { get; private set; } 
	public Address() { } 
	public Address(string street, string city, string state, string country, string zipcode) { Street = street; City = city; State = state; Country = country; ZipCode = zipcode; } 
	protected override IEnumerable<object> GetEqualityComponents() { yield... }
}
```

2. Special case

![[Снимок экрана 2024-01-19 в 07.18.03.png]]
![[Снимок экрана 2024-01-19 в 07.18.48.png]]

**Пример реализации:** ![[Снимок экрана 2024-01-19 в 07.19.14.png]]
## 5. Паттерны проектирования
---
#### 5.1. Фабричный метод. Абстрактная фабрика. Примеры. 

1. Фабричный метод

**Фабричный метод** также известный как Виртуальный конструктор  - пораждающий шаблон проектирования, определяющий общий интерфейс создания объектов в родительском классе и позволяющий изменять создаваемые объекты в дочерних классах. Шаблон позволяет классу делегировать создание объектов подклассам. 

**Когда надо применять паттерн:**
- Когда заранее неизвестно, объекты каких типов необходимо создавать
- Когда система должна быть независимой от процесса создания новых объектов и расширяемой: в нее можно легко вводить новые классы, объекты которых система должна создавать.
- Когда создание новых объектов необходимо делегировать из базового класса классам наследникам

**Пример:**
Представьте, что вы создали программу управления доставкой еды. В программе в качестве единственного средства доставки используется электро-самокат. Ваши курьеры на электро-самокатах развозят еду из пункта А в пункт Б. Все просто.  

Программа набирает популярность и ваш бизнес растет. Парк самокатов ограничен и вы решаете подключить к вашей системе доставки велосипеды, такси, квадрокоптеры и роботов-курьеров. Вам важно знать когда будет доставлена еда и сколько единиц продуктов может забрать курьер. У новых транспортных средств разная скорость и вместимость.

Вы обнаруживаете, что большая часть ваших сущностей в программе сильно связаны с объектом Самокат и чтобы заставить вашу программу работать с другими способами доставки, вам придется добавить связи в 80% вашей кодовой базы и так повторить для каждого нового транспорта. Знакомая ситуация?  

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от транспорта.

Фабричный метод предлагает создавать объекты транспорта через вызов специального метода. Подклассы класса, который содержит фабричный метод могут изменять создаваемые объекты конкретных создаваемых транспортов. На первый взгляд, это может показаться бессмысленным: мы просто переместили вызов конструктора из одного конца программы в другой. Но теперь вы сможете переопределять фабричный метод в подклассе, чтобы изменить тип создаваемого транспорта. 

Чтобы такая система заработала, все возвращаемые объекты имеют общий интерфейс, а подклассы могут производить объекты различных классов, имеющих общий интерфейс.

![[Снимок экрана 2024-01-19 в 05.49.41.png]]

2. Абстрактная фабрика

**Абстрактная фабрика** (Abstract factory) — это порождающий шаблон проектирования, который предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.

**Когда использовать абстрактную фабрику**:
- Когда система не должна зависеть от способа создания и компоновки новых объектов
- Когда создаваемые объекты должны использоваться вместе и являются взаимосвязанными

**Абстрактная фабрика** – это «фабрика фабрик». Но здесь появляется второй вопрос: «Для чего вообще может кому-нибудь понадобиться «фабрика фабрик»?

**Пример:**
Начнем с того, что может быть семейством взаимосвязанных объектов? Предположим, мы разрабатываем с тобой стратегию, и в ней есть несколько боевых единиц:
- пехота;
- кавалерия;
- лучники.

Эти типы боевых единиц связаны между собой, ведь они несут службу в одной армии. Мы можем сказать, что перечисленные выше категории — это семейство взаимосвязанных объектов. Но паттерн абстрактная фабрика применяют для организации создания **различных** семейств взаимосвязанных объектов. Продолжим пример со стратегией. В них, как правило, есть несколько различных противоборствующих сторон. У разных сторон боевые единицы могут существенно различаться внешне. Пехотинцы, всадники и лучники римской армии — не то же самое, что пехотинцы, всадники и лучники викингов. В рамках стратегии, солдаты разных армий — это различные семейства взаимосвязанных объектов. Было бы забавно, если по ошибке программиста в рядах римских пехотинцев разгуливал солдат во французском мундире времен Наполеона, с мушкетом наперевес. Именно для решения такой проблемы нужен шаблон проектирования абстрактная фабрика.

**Абстракция** — важнейший принцип данного паттерна. Клиенты фабрики работают с ней и с продуктами только через абстрактные интерфейсы. Поэтому можно не задумываться о том, каких воинов мы сейчас создаем, а передать эту обязанность какой-нибудь конкретной реализации абстрактной фабрики.

![[Снимок экрана 2024-01-19 в 05.57.05.png]]
#### 5.2. Строитель. Прототип. Одиночка. Примеры.

1. Строитель

**Строитель** (Builder) - шаблон проектирования, который инкапсулирует создание объекта и позволяет разделить его на различные этапы.

**Когда использовать паттерн:**
- Когда процесс создания нового объекта не должен зависеть от того, из каких частей этот объект состоит и как эти части связаны между собой
- Когда необходимо обеспечить получение различных вариаций объекта в процессе его создания

![[Снимок экрана 2024-01-19 в 05.58.43.png]]

2. Прототип

Паттерн **Прототип** (Prototype) позволяет создавать объекты на основе уже ранее созданных объектов-прототипов. То есть по сути данный паттерн предлагает технику клонирования объектов.

Когда использовать:
- Когда конкретный тип создаваемого объекта должен определяться динамически во время выполнения
- Когда нежелательно создание отдельной иерархии классов фабрик для создания объектов-продуктов из параллельной иерархии классов (как это делается, например, при использовании паттерна Абстрактная фабрика)
- Когда клонирование объекта является более предпочтительным вариантом нежели его создание и инициализация с помощью конструктора. Особенно когда известно, что объект может принимать небольшое ограниченное число возможных состояний.

![[Снимок экрана 2024-01-19 в 06.02.15.png]]

3. Одиночка

**Одиночка** (Singleton, Синглтон) - порождающий паттерн, который гарантирует, что для определенного класса будет создан только один объект, а также предоставит к этому объекту точку доступа.

Когда надо использовать Синглтон? Когда необходимо, чтобы для класса существовал только один экземпляр

Синглтон позволяет создать объект только при его необходимости. Если объект не нужен, то он не будет создан. В этом отличие синглтона от глобальных переменных.

**Пример:**
```csharp
class Computer {
    public OS OS { get; set; }
    public void Launch(string osName)
    {
        OS = OS.getInstance(osName);
    }
}

class OS
{
    private static OS instance;
    public string Name { get; private set; }
    protected OS(string name)
    {
        this.Name=name;
    }
    public static OS getInstance(string name)
    {
        if (instance == null)
            instance = new OS(name);
        return instance;
    }
}
```

#### 5.3. Адаптер. Мост. Примеры.

1. Адаптер

Паттерн **Адаптер** (Adapter) предназначен для преобразования интерфейса одного класса в интерфейс другого. Благодаря реализации данного паттерна мы можем использовать вместе классы с несовместимыми интерфейсами.

**Когда надо использовать:**
- Когда необходимо использовать имеющийся класс, но его интерфейс не соответствует потребностям
- Когда надо использовать уже существующий класс совместно с другими классами, интерфейсы которых не совместимы

![[Снимок экрана 2024-01-19 в 06.07.38.png]]

**Пример:**
Представь, что у нас есть какая-то карта памяти. В чем состоит проблема? В том, что она не умеет взаимодействовать с компьютером. У них нет общего интерфейса. У компьютера есть разъем USB, но карту памяти в него не вставить. Карту невозможно вставить в компьютер, из-за чего мы не сможем сохранить наши фотографии, видео и другие данные. Кардридер является адаптером, решающим данную проблему. Ведь у него есть USB-кабель! В отличие от самой карты, кардридер можно вставить в компьютер. У них с компьютером есть общий интерфейс — USB.

2. Мост

**Мост** (Bridge) - структурный шаблон проектирования, который позволяет отделить абстракцию от реализации таким образом, чтобы и абстракцию, и реализацию можно было изменять независимо друг от друга.

Даже если мы отделим абстракцию от конкретных реализаций, то у нас все равно все наследуемые классы будут жестко привязаны к интерфейсу, определяемому в базовом абстрактном классе. Для преодоления жестких связей и служит паттерн Мост.

Общая реализация паттерна состоит в объявлении классов абстракций и классов реализаций в отдельных параллельных иерархиях классов.

**Когда использовать данный паттерн:**
- Когда надо избежать постоянной привязки абстракции к реализации
- Когда наряду с реализацией надо изменять и абстракцию независимо друг от друга. То есть изменения в абстракции не должно привести к изменениям в реализации

![[Снимок экрана 2024-01-19 в 06.11.31.png]]
#### 5.4. Компоновщик. Декоратор. Примеры.

1. Компоновщик

Паттерн **Компоновщик** (Composite) объединяет группы объектов в древовидную структуру по принципу "часть-целое и позволяет клиенту одинаково работать как с отдельными объектами, так и с группой объектов.

Образно реализацию паттерна можно представить в виде меню, которое имеет различные пункты. Эти пункты могут содержать подменю, в которых, в свою очередь, также имеются пункты. То есть пункт меню служит с одной стороны частью меню, а с другой стороны еще одним меню. В итоге мы однообразно можем работать как с пунктом меню, так и со всем меню в целом.

**Когда использовать компоновщик:**
- Когда объекты должны быть реализованы в виде иерархической древовидной структуры
- Когда клиенты единообразно должны управлять как целыми объектами, так и их составными частями. То есть целое и его части должны реализовать один и тот же интерфейс

![[Снимок экрана 2024-01-19 в 08.16.10.png]]

**Участники**
- *Component*: определяет интерфейс для всех компонентов в древовидной структуре
- *Composite*: представляет компонент, который может содержать другие компоненты и реализует механизм для их добавления и удаления
- *Leaf*: представляет отдельный компонент, который не может содержать другие компоненты
- *Client*: клиент, который использует компоненты

**Пример:**
Допустим мы хотим распечатать содержание книги. В содержании, как раз и просматривается древовидная структура. Каждая глава книги содержит в себе составные части — параграфы. Приступим к написанию кода.

**Пример реализации:**
```csharp
class Client 
{ 
	public void Main() 
	{ 
		Component root = new Composite("Root"); 
		Component leaf = new Leaf("Leaf"); 
		Composite subtree = new Composite("Subtree"); 
		root.Add(leaf); 
		root.Add(subtree); 
		root.Display(); } 
	} 

abstract class Component 
{ 
	protected string name; 
	
	public Component(string name) 
	{ 
		this.name = name; 
	} 
	
	public abstract void Display(); 
	public abstract void Add(Component c); 
	public abstract void Remove(Component c); 
} 

class Composite : Component 
{ 
	List<Component> children = new List<Component>(); 
	
	public Composite(string name) : base(name) {} 
	
	public override void Add(Component component) { children.Add(component); } 
	
	public override void Remove(Component component) 
	{ 
		children.Remove(component); 
	} 
	
	public override void Display() 
	{ 
		Console.WriteLine(name); 
		foreach (Component component in children) 
		{ 
			component.Display(); 
		} 
	} 
} 

class Leaf : Component 
{ 
	public Leaf(string name) : base(name) {} 
	
	public override void Display() { Console.WriteLine(name); } 
	
	public override void Add(Component component) 
	{ 
		throw new NotImplementedException(); 
	} 
	
	public override void Remove(Component component) 
	{ 
		throw new NotImplementedException(); 
	} 
}
```

2. Декоратор

Декоратор (Decorator) представляет структурный шаблон проектирования, который позволяет динамически подключать к объекту дополнительную функциональность.

Для определения нового функционала в классах нередко используется наследование. Декораторы же предоставляет наследованию более гибкую альтернативу, поскольку позволяют динамически в процессе выполнения определять новые возможности у объектов.

**Когда следует использовать декораторы:**
- Когда надо динамически добавлять к объекту новые функциональные возможности. При этом данные возможности могут быть сняты с объекта
- Когда применение наследования неприемлемо. Например, если нам надо определить множество различных функциональностей и для каждой функциональности наследовать отдельный класс, то структура классов может очень сильно разрастись. Еще больше она может разрастись, если нам необходимо создать классы, реализующие все возможные сочетания добавляемых функциональностей.

![[Снимок экрана 2024-01-19 в 08.25.53.png]]

**Участники**:
- **Component**: абстрактный класс, который определяет интерфейс для наследуемых объектов.
- **ConcreteComponent**: конкретная реализация компонента, в которую с помощью декоратора добавляется новая функциональность.
- **Decorator**: собственно декоратор, реализуется в виде абстрактного класса и имеет тот же базовый класс, что и декорируемые объекты. Поэтому базовый класс Component должен быть по возможности легким и определять только базовый интерфейс. Класс декоратора также хранит ссылку на декорируемый объект в виде объекта базового класса Component и реализует связь с базовым классом как через наследование, так и через отношение агрегации.
- **Классы** ConcreteDecoratorA и ConcreteDecoratorB представляют дополнительные функциональности, которыми должен быть расширен объект ConcreteComponent.

Декораторы отлично подходят для решения следующих задач:
- кэширования результатов работы; 
- замера времени исполнения методов; 
- логирования аргументов;
- управления доступом пользователей;
- модификации аргументов или результата работы методов упаковки/распаковки, шифрования и т. п.

**Примеры**:
1. Логирование и инструментарий: Декораторы могут быть использованы для логирования и инструментария. Применяя декораторы к методам или классам, вы можете отслеживать вызовы методов, измерять производительность, записывать в логи отладочную информацию или добавлять другие возможности мониторинга. Это позволяет собирать ценные данные во время работы без изменения исходной реализации.
2. Авторизация и аутентификация: Декораторы можно использовать для добавления проверок авторизации и аутентификации в методы или компоненты. Обернув объекты декораторами, вы можете применять меры безопасности, такие как проверка прав доступа пользователей или проверка аутентификационных маркеров, до выполнения основной логики. Это обеспечивает модульный подход к интеграции функций безопасности в различные части приложения.
#### 5.5. Фасад. Легковес. Заместитель. Примеры.
#### 5.6. Команда. Состояние. Итератор. Примеры.
#### 5.7. Посредник. Снимок. Примеры.
#### 5.8. Наблюдатель. Посетитель. Примеры.

1. Наблюдатель

Паттерн **"Наблюдатель" **(Observer) представляет поведенческий шаблон проектирования, который использует отношение "один ко многим". В этом отношении есть один наблюдаемый объект и множество наблюдателей. И при изменении наблюдаемого объекта автоматически происходит оповещение всех наблюдателей.

Данный паттерн еще называют Publisher-Subscriber (издатель-подписчик), поскольку отношения издателя и подписчиков характеризуют действие данного паттерна: подписчики подписываются email-рассылку определенного сайта. Сайт-издатель с помощью email-рассылки уведомляет всех подписчиков о изменениях. А подписчики получают изменения и производят определенные действия: могут зайти на сайт, могут проигнорировать уведомления и т.д.

**Когда использовать паттерн:**
- Когда система состоит из множества классов, объекты которых должны находиться в согласованных состояниях
- Когда общая схема взаимодействия объектов предполагает две стороны: одна рассылает сообщения и является главным, другая получает сообщения и реагирует на них. Отделение логики обеих сторон позволяет их рассматривать независимо и использовать отдельно друга от друга.
- Когда существует один объект, рассылающий сообщения, и множество подписчиков, которые получают сообщения. При этом точное число подписчиков заранее неизвестно и процессе работы программы может изменяться.

![[Снимок экрана 2024-01-19 в 08.30.53.png]]

**Примеры**: Redux

2. Посетитель

Паттерн **Посетитель** (Visitor) позволяет определить операцию для объектов других классов без изменения этих классов.

При использовании паттерна Посетитель определяются две иерархии классов: одна для элементов, для которых надо определить новую операцию, и вторая иерархия для посетителей, описывающих данную операцию.

**Когда использовать данный паттерн:**
- Когда имеется много объектов разнородных классов с разными интерфейсами, и требуется выполнить ряд операций над каждым из этих объектов
- Когда классам необходимо добавить одинаковый набор операций без изменения этих классов
- Когда часто добавляются новые операции к классам, при этом общая структура классов стабильна и практически не изменяется

Идея достаточно простая — вместо того, чтобы объявлять поведение внутри класса, мы делегируем это поведение некоторому внешнему объекту. При этом объект-делегат называется посетителем (Visitor), и в нем должны быть объявлены методы посещения для каждого конкретного типа из иерархии.

![[Снимок экрана 2024-01-19 в 08.34.51.png]]

**Примеры:** характеристика Здоров/Не здоров у пациентов (школьников) определяет доктор
#### 5.9. Цепочка обязанностей. Стратегия. Шаблонный метод. Примеры.